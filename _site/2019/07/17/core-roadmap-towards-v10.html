<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Core roadmap: towards v10 | Concourse Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Core roadmap: towards v10" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A long-term roadmap for the core design of Concourse, a general-purpose CI/CD tool." />
<meta property="og:description" content="A long-term roadmap for the core design of Concourse, a general-purpose CI/CD tool." />
<link rel="canonical" href="http://localhost:4000/2019/07/17/core-roadmap-towards-v10.html" />
<meta property="og:url" content="http://localhost:4000/2019/07/17/core-roadmap-towards-v10.html" />
<meta property="og:site_name" content="Concourse Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-17T19:16:58-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Core roadmap: towards v10" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-07-17T19:16:58-04:00","datePublished":"2019-07-17T19:16:58-04:00","description":"A long-term roadmap for the core design of Concourse, a general-purpose CI/CD tool.","headline":"Core roadmap: towards v10","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/07/17/core-roadmap-towards-v10.html"},"url":"http://localhost:4000/2019/07/17/core-roadmap-towards-v10.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Concourse Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Concourse Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Core roadmap: towards v10</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-07-17T19:16:58-04:00" itemprop="datePublished">Jul 17, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><em>A long-term roadmap for the core design of <a href="https://concourse-ci.org">Concourse</a>, a general-purpose CI/CD tool.</em></p>

<p><em><a href="https://vito.github.io/slides/v10.html">Accompanying slides</a>. Recommended viewing: <a href="https://www.youtube.com/watch?v=2ot9eV9DybI">episode 1 of Yu-Gi-Oh</a>.</em></p>

<p>Concourse’s design philosophy is to be expressive, versatile, and safe while limited to a handful of simple, proven concepts. The design of these concepts should make good practices feel intuitive and bad practices feel uncomfortable.</p>

<p>Coming up with these designs can be very challenging. There are many different workflows and patterns across the software industry, and they each have to be deeply understood in order to know what the good and bad practices are.</p>

<p>This post provides a bit of insight into what we’ve been up to with Concourse’s core design - chiefly regarding ‘spaces’, which has become a bit of a white whale on our roadmap.</p>

<p>There are a lot of words here - sorry! If you just want to skim, I’ve added a single-paragraph summary under each roadmap entry.</p>

<p>Each roadmap entry corresponds to an RFC or an issue, linked in their header. If you want to get involved in our design process or just provide feedback, please check them out and submit a PR review! (Thanks!)</p>

<!--kg-card-begin: markdown-->
<h2 id="table-of-contents">Table of contents</h2>

<ol>
  <li><a href="#where-is-spaces-">Where is ‘spaces’?</a></li>
  <li><a href="#where-are-we-now">Where are we now?</a>
    <ul>
      <li><a href="#issue-3602-a-new-algorithm">Issue #3602: a new algorithm</a></li>
      <li><a href="#issue-413-build-re-triggering">Issue #413: build re-triggering</a></li>
    </ul>
  </li>
  <li><a href="#where-are-we-going">Where are we going?</a>
    <ul>
      <li><a href="#rfc-24-resources-v2">RFC #24: resources v2</a></li>
      <li><a href="#rfc-26-artifact-resources">RFC #26: artifact resources</a></li>
      <li><a href="#rfc-31-set_pipeline-step">RFC #31: <code class="language-plaintext highlighter-rouge">set_pipeline</code> step</a></li>
      <li><a href="#rfc-32-projects">RFC #32: projects</a></li>
      <li><a href="#rfc-33-archiving-pipelines">RFC #33: archiving pipelines</a></li>
      <li><a href="#rfc-34-instanced-pipelines">RFC #34: instanced pipelines</a></li>
      <li><a href="#rfc-29-spatial-resources">RFC #29: spatial resources</a></li>
      <li><a href="#rfc-27-trigger-resources">RFC #27: trigger resources</a></li>
      <li><a href="#rfc-28-notification-resources">RFC #28: notification resources</a></li>
    </ul>
  </li>
  <li><a href="#what-comes-after-all-this">What comes after all this?</a></li>
  <li><a href="#thanks-">Thanks!</a>
<!--kg-card-end: markdown-->
    <h1 id="where-is-spaces">Where is ‘spaces’?</h1>
  </li>
</ol>

<p>For those of you not familiar with <a href="https://github.com/concourse/concourse/issues/1707">spaces</a>, it was a big ol’ feature that enabled the following workflows:</p>

<ul>
  <li>Dynamically running against things like branches/pull requests, which change over time (i.e. commits to a branch) <em>and</em> space (i.e. the set of branches themselves). Hence the name ‘spaces.’</li>
  <li>Fanning in using <code class="language-plaintext highlighter-rouge">passed</code> constraints across spaces. This is currently impossible to do with separate pipelines, because pipelines can’t reference each other’s resources.</li>
  <li>Automatically cleaning up spaces for closed PRs, etc. This is annoying to automate and requires keeping track of state.</li>
</ul>

<p>These workflows still make sense, so why is ‘spaces’ dead?</p>

<p>Well, I approached it the wrong way. To me, the idea of resources tracking change over time and space felt pretty solid from a theoretical standpoint. In hindsight, maybe it just sounded cool.</p>

<p>I had no reservations baking ‘spaces’ in to every layer of the stack - it would add more depth to all the existing ideas. Everything was going to change: the resource interface, the web UI, how jobs work… It was all so exciting!</p>

<p>But as time went on it became terrifying. It was a double-or-nothing bet. Either ‘spaces’ made sense everywhere, or ‘spaces’ didn’t make sense at all. I tried to carve out work that could be done before fully committing to spaces, but it didn’t make the monolithic feature any less monolithic.</p>

<figure class="kg-card kg-image-card kg-card-hascaption"><img src=" __GHOST_URL__ /content/images/2019/07/scaredy-cat-2.gif" class="kg-image" alt="" loading="lazy" /><figcaption>me vs the space dragon</figcaption></figure>
<h1 id="where-are-we-now">Where are we now?</h1>

<p>First off, I want to give a quick update on a couple of big things that you can expect in v6.0:</p>

<h2 id="issue-3602-a-new-algorithm"><a href="https://github.com/concourse/concourse/issues/3602">Issue #3602</a>: a new algorithm</h2>

<p><em>We are re-designing the algorithm used for determining the candidate input versions for a job. The new approach will rely less on brute force and will perform better with large installations.</em></p>

<p>This new algorithm fixes long-standing architectural issues with the old one, which loaded each pipeline’s entire build and resource version history into memory and determined valid candidates using brute force.</p>

<p>The key difference between the old and new algorithm is how <code class="language-plaintext highlighter-rouge">passed</code> constraints are implemented, specifically when multiple inputs depend on the same job:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plan:
- get: foo
  passed: [foo-unit, integration]
- get: bar
  passed: [bar-unit, integration]
- get: baz
  passed: [integration]
</code></pre></div></div>

<p>In Concourse, this means “give me versions of <code class="language-plaintext highlighter-rouge">foo</code>, <code class="language-plaintext highlighter-rouge">bar</code>, and <code class="language-plaintext highlighter-rouge">baz</code> that have passed through <code class="language-plaintext highlighter-rouge">integration</code> <em>together in the same build</em>, with the same version of <code class="language-plaintext highlighter-rouge">foo</code> having passed <code class="language-plaintext highlighter-rouge">foo-unit</code> and the same version of <code class="language-plaintext highlighter-rouge">bar</code> having passed <code class="language-plaintext highlighter-rouge">bar-unit</code>.”</p>

<p>How does this work? Well, it’s hard to describe either algorithm succinctly, but I’ll try:</p>

<ul>
  <li>The old algorithm goes through resource versions, newest first, and checks whether each version satisfies the input’s own <code class="language-plaintext highlighter-rouge">passed</code> constraints. Next it checks that any other already-chosen input versions which mention the same job in <em>their</em> <code class="language-plaintext highlighter-rouge">passed</code> constraints also came from the same build, recursing and walking through versions until everything is satisfied. This process is brute-force, an uses a lot of CPU.</li>
  <li>The new algorithm instead loops over <em>build output version sets</em> via the jobs listed in each <code class="language-plaintext highlighter-rouge">passed</code> constraint, assigning all the relevant versions for a given build at once as long as the versions match the other already-chosen versions assigned via builds of prior jobs in the <code class="language-plaintext highlighter-rouge">passed</code> constraint.</li>
</ul>

<p>This new approach really simplifies things because the versions are <em>inherently</em> coming from the same build. Now that we don’t have to do the extra cross-referencing, the new flow can just make a handful of cheap database queries instead of having to load the whole pipeline’s dataset into memory.</p>

<p>We’ve been testing the old and new algorithm in two separate environments, each at the scale of 1,000 jobs with varying <code class="language-plaintext highlighter-rouge">passed</code> constraints and a sprinkle of <code class="language-plaintext highlighter-rouge">version: every</code> across four <code class="language-plaintext highlighter-rouge">web</code> nodes.</p>

<ul>
  <li>The old algorithm starts off very fast but grows slower and slower as the pipeline dataset grows, eventually exhausting the <code class="language-plaintext highlighter-rouge">web</code> nodes of RAM and swap.</li>
  <li>The new algorithm starts off slightly slower than the old one - it’s hard to beat an in-memory dataset - but it stays stable, uses less CPU, and does not leak memory.</li>
</ul>

<p>We’re making a few final touches as we to get as much performance out of the new algorithm as possible, since we don’t tend to touch it often. Once we’re finished, we’ll jump straight to…:</p>

<h2 id="issue-413-build-re-triggering"><a href="https://github.com/concourse/concourse/issues/413">Issue #413</a>: build re-triggering</h2>

<p><em>The new algorithm changes the behavior for today’s pinning-based flow for re-triggering a build, so we’re going to implement proper support for build re-triggering and ship these two features together in v6.0.</em></p>

<p>Right now the only way to “re-trigger” a build is to pin each of the job’s upstream resources to the version from the build, trigger a new build, and go back and un-pin them all. It’s pretty cumbersome and error-prone.</p>

<p>It also kind of breaks with the new algorithm. Now that the new algorithm is based on <em>build output sets</em> and not version history, once the new build succeeds its older versions will end up being the first set attempted for that job, potentially propagating them to downstream jobs.</p>

<p>That’s not what I would expect from a <em>re-trigger</em>. I would expect a re-trigger to act “in-place,” while preserving the logs of the original failure for posterity.</p>

<p>To avoid this surprising change in behaviour, we’re going to implement build re-triggering properly and stop abusing the version pinning feature, which was originally designed for temporarily pinning a broken upstream dependency to a “known good” one.</p>

<p>Build re-triggering will be implemented in a way that preserves the order of the builds that the algorithm will go over. If the re-triggered build succeeds, its set of outputs will be available to downstream jobs based on the original build’s order.</p>

<p>Another benefit to implementing re-triggering soon is that folks using a pull request resource will have a much easier time re-triggering failed pull requests, without having to wait on the rest of the roadmap (i.e. ‘spaces’).</p>

<h1 id="where-are-we-going">Where are we going?</h1>

<p>So, going back to the ‘spaces’ initiative. The pieces really started to fall into place over the past few months, and I think I’ve arrived at a roadmap that accomplishes all of the goals of ‘spaces’ but in a significantly more Concourse-y way.</p>

<p>Instead of one monolithic feature, I have a bunch of smaller features to propose that are independently valuable and can be delivered in any order. As we complete them, a bigger picture will start to take shape.</p>

<p>Let’s jump right in!</p>

<h2 id="rfc-24-resources-v2"><a href="https://github.com/concourse/rfcs/pull/24">RFC #24</a>: resources v2</h2>

<p><em>Resources v2 is the first major revision of the resource interface since Concourse’s inception. It’s a step to take very carefully. I think we’re finally ready to go.</em></p>

<p><strong>UPDATE: Just kidding! This proposal has been superceded by something even more general: <a href="__GHOST_URL__ /reinventing-resource-types/">Prototypes</a>! (<a href="https://github.com/concourse/rfcs/blob/master/037-prototypes/proposal.md">RFC #37</a>)</strong></p>

<p>The v2 interface brings long-awaited polish to the interface: it renames <code class="language-plaintext highlighter-rouge">in</code> and <code class="language-plaintext highlighter-rouge">out</code> to <code class="language-plaintext highlighter-rouge">get</code> and <code class="language-plaintext highlighter-rouge">put</code> to match their step names, introduces a <code class="language-plaintext highlighter-rouge">delete</code> action, standardises TLS configuration, and revises terminology so as to not be coupled to the ‘versioned artifacts’ use case.</p>

<p>The latest proposal for Resources v2, <a href="https://github.com/concourse/rfcs/pull/24">RFC #24</a>, is a lot like <a href="https://github.com/concourse/rfcs/pull/1">RFC #1</a> but with one big difference: ‘spaces’ is no longer a foundational piece of the interface. Instead, RFC #24 proposes that we generalize and simplify the interface to an extent that it can be used for various pipeline workflows, not just versioning artifacts.</p>

<p>The new direction is to leverage composition between resources and pipelines via <em>config fragments</em>, which can be passed from one resource to another or used for <code class="language-plaintext highlighter-rouge">((vars))</code> in a pipeline template. ‘Config fragments’ replace ‘versions’ in the interface, and are used as versions for the ‘versioned artifacts’ flow (today’s primary use of resources).</p>

<p>By generalizing the resource concept we set the stage for proper pipeline-level support for notifications (e.g. Slack alerts, GitHub commit status), trigger-only resources (e.g. <code class="language-plaintext highlighter-rouge">time</code>), and spatial resources (e.g. branches, pull requests) without tying each use case into the interface itself.</p>

<p>Now that ‘spaces’ is gone from the interface, the actual change in the interface protocol is somewhat cosmetic. As a result, Concourse pipelines will be able to use v1 and v2 resources side-by-side for all the same functionality. This way we can move forward with pipeline-level resource features without fragmenting the resource ecosystem!</p>

<h2 id="rfc-26-artifact-resources"><a href="https://github.com/concourse/rfcs/pull/26">RFC #26</a>: artifact resources</h2>

<p><em>Artifact resources are an interpretation of the generic resource interface that maps to today’s usage of the resource interface.</em></p>

<p><strong>UPDATE: this is now <a href="https://github.com/concourse/rfcs/blob/master/038-resource-prototypes/proposal.md">RFC #38</a>, “Resource Prototypes”</strong></p>

<p>Artifact resources use config fragments as <em>versions</em>, modeling change to an external entity over time. This should sound familiar to anyone using Concourse today: they’re the sole use case that Concourse resources were originally designed around.</p>

<p>The ‘artifact resources’ proposal clarifies that this is now just <em>one</em> use case for the general resource interface, and outlines a few long-awaited features:</p>

<ul>
  <li>Versions can be deleted using the <code class="language-plaintext highlighter-rouge">delete</code> action in the resource interface.</li>
  <li>The <code class="language-plaintext highlighter-rouge">put</code> action can emit multiple versions. Each will be recorded as an output of the build.</li>
  <li>The automatic <code class="language-plaintext highlighter-rouge">get</code> after the <code class="language-plaintext highlighter-rouge">put</code> step will be made opt-in. (Huzzah!)</li>
</ul>

<p>The automatic <code class="language-plaintext highlighter-rouge">get</code> after each <code class="language-plaintext highlighter-rouge">put</code> is something that has confused and occasionally frustrated users, but we didn’t want to break backwards compatibility and we didn’t want users to have to ‘opt out’ (that’s too many <a href="https://github.com/concourse/concourse/wiki/Anti-Patterns#knobs">knobs</a> to turn).</p>

<p>This RFC will provide a backwards-compatible transition path to artifact resources. Check out <a href="https://github.com/concourse/rfcs/pull/26">RFC #26</a> for more details!</p>

<h2 id="rfc-31-set_pipeline-step"><a href="https://github.com/concourse/rfcs/pull/31">RFC #31</a>: <code class="language-plaintext highlighter-rouge">set_pipeline</code> step</h2>

<p><em>The first step on our journey towards ‘spaces’ is to introduce a simple, but critical piece of the puzzle: a <code class="language-plaintext highlighter-rouge">set_pipeline</code> step.</em></p>

<p>The <code class="language-plaintext highlighter-rouge">set_pipeline</code> step is used like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: bootstrap
  plan:
  - get: ci
    trigger: true
  - set_pipeline: concourse
    file: ci/pipelines/concourse.yml
</code></pre></div></div>

<p>This job will configure a <code class="language-plaintext highlighter-rouge">concourse</code> pipeline within the job’s team. The pipeline will be automatically unpaused, and no authentication is required.</p>

<p>The first thing this lets us do is deprecate the <code class="language-plaintext highlighter-rouge">concourse-pipeline</code> resource, which has two pretty fundamental problems:</p>

<ul>
  <li>Having to configure auth is really awkward - you have to set up a local user and give the resource the keys to the kingdom.</li>
  <li>Keeping the version of <code class="language-plaintext highlighter-rouge">fly</code> within the resource in sync with your own Concourse’s version is a bit clunky.</li>
</ul>

<p>With the <code class="language-plaintext highlighter-rouge">set_pipeline</code> step, both of these problems immediately go away and pipelines start to feel a more first-class rather than just being the tip of the abstraction iceberg.</p>

<h2 id="rfc-32-projects"><a href="https://github.com/concourse/rfcs/pull/32">RFC #32</a>: projects</h2>

<p>Ok, I promised to provide a tl;dr for each roadmap entry, but projects can’t really be summed up that easily. This is the most impactful feature on this roadmap.</p>

<ul>
  <li><em>A “project” is a new concept bootstrapped by two existing ones: a <a href="https://concourse-ci.org/resources.html">resource</a> from which to continuously load the project’s config, which specifies a <a href="https://concourse-ci.org/steps.html">build plan</a> to execute whenever the project resource changes.</em></li>
  <li><em>Projects act as a namespace for pipelines, and provide a long-requested workflow for automating their configuration. As the roadmap goes on, this workflow becomes more and more powerful.</em></li>
  <li><em>Projects allow you to define project-wide resources which let you clean up duplicate definitions across your pipelines and support cross-pipeline <code class="language-plaintext highlighter-rouge">passed</code> constraints.</em></li>
  <li><em>Projects also define project-wide tasks, which remove the need to thread a resource through all your jobs just to have the task configs to execute, and finally gives meaning to task names (the <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">task: x</code>).</em></li>
</ul>

<p>A project’s build plan can be used for anything you want. Small projects could use the build plan to run tests and/or perform various steps in a single build - a workflow more familiar to users of other CI systems:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name: ci
plan:
- get: booklit
  trigger: true
- task: unit
</code></pre></div></div>

<p>Larger projects could use the build plan to execute <code class="language-plaintext highlighter-rouge">set_pipeline</code> steps. Concourse has long encouraged users to keep their pipelines under source control, but it never enforced it: <code class="language-plaintext highlighter-rouge">fly set-pipeline</code> was still a manual operation, and users would often forget to check in their changes. Projects will fix that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name: ci
plan:
- set_pipeline: booklit
</code></pre></div></div>

<p>Small projects may start without pipelines and start using pipelines as they grow. Our original slogan, ‘CI that scales with your project,’ is now pretty literal! The hope is that by introducing build plans without requiring knowledge of pipelines and jobs, we’ll have made Concourse’s learning curve more gradual and made Concourse feel less overkill for side-projects.</p>

<p>This feature will have far-reaching implications for Concourse, so it won’t be sneaking in quietly. I’ve opened <a href="https://github.com/concourse/rfcs/pull/32">RFC #32</a> and would really appreciate feedback!</p>

<h2 id="rfc-33-archiving-pipelines"><a href="https://github.com/concourse/rfcs/pull/33">RFC #33</a>: archiving pipelines</h2>

<p><em>Archiving pipelines is a way to soft-delete a pipeline while still being able to peruse the build history for a pipeline you no longer want.</em></p>

<p>Well, after that bombshell this one’s pretty easy to explain. Let’s take a look at our own Concourse team’s pipelines:</p>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2019/07/Screenshot-from-2019-07-16-11-49-33.png" class="kg-image" alt="" loading="lazy" /></figure>

<p>Look at all that cruft! So many old, paused or bit-rotting pipelines which I really don’t care about anymore but don’t really have the heart to delete. That <code class="language-plaintext highlighter-rouge">old-concourse</code> pipeline served us well for years - it has sentimental value. In some cases you may also want to keep the history around for auditing purposes.</p>

<p>Archiving pipelines will allow you to humanely retire a pipeline in a way that gets it out of your way while still allowing you to peruse the build history should you ever need to. Archived pipelines are no longer active and will allow you to re-use their name without bringing the old pipeline back.</p>

<p>There’s already an open pull request for this: <a href="https://github.com/concourse/concourse/issues/2518">#2518</a> - shout-out to <a href="https://github.com/tkellen">@tkellen</a>! The ball has been in our court for a while to figure out the UI/UX, so we’re just going to submit a new RFC and work out all the details.</p>

<h2 id="rfc-34-instanced-pipelines"><a href="https://github.com/concourse/rfcs/pull/34">RFC #34</a>: instanced pipelines</h2>

<p><em>Instanced pipelines group together pipelines which share a common template configured with different <code class="language-plaintext highlighter-rouge">((vars))</code>. They provide a simple two-level hierarchy and automatic archiving of instances which are no longer needed.</em></p>

<p>Instanced pipelines are an important piece of the ‘spaces’ puzzle: it’s how users will navigate through their spatial pipelines, and it’s what keeps no-longer-relevant spaces for e.g. merged PRs and deleted branches from piling up forever.</p>

<p>Pipeline instances are created using the <code class="language-plaintext highlighter-rouge">set_pipeline</code> step like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plan:
- set_pipeline: branch
  instance_vars:
    branch: feature/projects
- set_pipeline: branch
  instance_vars:
    branch: feature/new-algorithm
</code></pre></div></div>

<p>At the end of a build which uses <code class="language-plaintext highlighter-rouge">set_pipeline</code>, all instances of the named pipelines which were not configured by the build will be automatically archived.</p>

<p>Check out <a href="https://github.com/concourse/rfcs/pull/34">RFC #34</a> for more details!</p>

<h2 id="rfc-29-spatial-resources"><a href="https://github.com/concourse/rfcs/pull/29">RFC #29</a>: spatial resources</h2>

<p><em>Spatial resources are resources whose <code class="language-plaintext highlighter-rouge">check</code> monitors spatial change, not change over time. Two common examples are the set of branches or open pull requests for a repo. The <code class="language-plaintext highlighter-rouge">across</code> step allows a build to process each ‘space’ and trigger on changes to the set.</em></p>

<p><strong>UPDATE: the syntax for this step has since been tweaked so that multi-var matrices don’t require nesting <code class="language-plaintext highlighter-rouge">across</code> steps.</strong></p>

<p>When used with the new <code class="language-plaintext highlighter-rouge">across</code> step, the  <code class="language-plaintext highlighter-rouge">set_pipeline</code> step, and instanced pipelines, this enables dynamic pipeline configuration across spatial change.</p>

<p>The final piece of the puzzle for ‘spaces’ is the addition of an <code class="language-plaintext highlighter-rouge">across</code> step. This step points to a resource and has a plan which will execute for <em>every config fragment</em> returned by the resource’s <code class="language-plaintext highlighter-rouge">check</code>, all within one build.</p>

<p>Let’s first look at a simple use case, which is to execute a task across many variants:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plan:
# ...
- across: supported-go-versions
  as: go
  do:
  - task: unit
    image: go
</code></pre></div></div>

<p>In this case, imagine we have a <code class="language-plaintext highlighter-rouge">supported-go-versions</code> resource whose <code class="language-plaintext highlighter-rouge">check</code> returns a config fragment for each tag and digest based on a pre-configured list of supported tags (e.g. <code class="language-plaintext highlighter-rouge">1.10</code>, <code class="language-plaintext highlighter-rouge">1.11</code>, <code class="language-plaintext highlighter-rouge">1.12</code>), and whose <code class="language-plaintext highlighter-rouge">in</code>/<code class="language-plaintext highlighter-rouge">get</code> fetches the image.</p>

<p>When nested, the <code class="language-plaintext highlighter-rouge">across</code> step enables dynamic build matrices:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plan:
# ...
- across: supported-go-versions
  as: go
  do: # needed so we can define another 'across'
  - across: other-things
    as: some-input
    task: unit
    image: go
</code></pre></div></div>

<p>When used with <code class="language-plaintext highlighter-rouge">set_pipeline</code> and instanced pipelines, it enables dynamic <em>pipeline</em> matrices:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plan:
- across: repo-branches
  as: repo-branch
  set_pipeline: branch
  instance_vars:
    branch_name: ((repo-branch.name))
</code></pre></div></div>

<p>(Assuming we provide the ability to access fields of an artifact with <code class="language-plaintext highlighter-rouge">((vars))</code>.)</p>

<h2 id="rfc-27-trigger-resources"><a href="https://github.com/concourse/rfcs/pull/27">RFC #27</a>: trigger resources</h2>

<p><em>Trigger resources allow jobs to specify parameters that can trigger new builds but don’t have anything to fetch - they just propagate config fragments to the build.</em></p>

<p><strong>UPDATE: this has turned into a <code class="language-plaintext highlighter-rouge">get_var</code> step, rather than a <code class="language-plaintext highlighter-rouge">param</code> step</strong></p>

<p>This is also a relatively simple feature, but it will improve today’s usage of the <code class="language-plaintext highlighter-rouge">time</code> resource by having per-job trigger semantics rather than having all jobs downstream of one <code class="language-plaintext highlighter-rouge">time</code> resource leading to a thundering herd of builds hitting your workers all at once.</p>

<p>Rough sketch:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: smoke-test
  plan:
  - param: 10m
    trigger: true
</code></pre></div></div>

<p>Semantically, <code class="language-plaintext highlighter-rouge">param</code> is similar to <code class="language-plaintext highlighter-rouge">get</code> but with one key difference: there is no central version history. Rather than being used as an <em>artifact</em>, the resource is used solely for its <em>config fragments.</em> Concourse will <code class="language-plaintext highlighter-rouge">check</code> against the job’s last used config fragment for the trigger resource, <code class="language-plaintext highlighter-rouge">10m</code>, and if a different fragment is returned the job will trigger with the new one.</p>

<p>This skips the <code class="language-plaintext highlighter-rouge">get</code>, eliminates the thundering herd issue (because all jobs have their own interval), and could enable an interesting pattern for manually-parameterized builds: just write a resource type that can fetch user-provided config fragments from some external source (i.e. a repo).</p>

<p>Here’s one idea of what that may look like, where the config fragments returned by param are somehow usable with <code class="language-plaintext highlighter-rouge">((vars))</code> syntax in subsequent steps:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plan:
- param: environment
- task: smoke-test
  vars:
    environment: ((environment.name))
</code></pre></div></div>

<p>Another interesting use case would be to use it as a <code class="language-plaintext highlighter-rouge">instance_fragment</code> with the <code class="language-plaintext highlighter-rouge">set_pipeline</code> step.</p>

<p>This idea is pretty half-baked - I’ve been mainly focusing on the ‘spatial resources’ idea. Follow along in the <a href="https://github.com/concourse/rfcs/pull/27">RFC #27</a> and help the idea develop!</p>

<h2 id="rfc-28-notification-resources"><a href="https://github.com/concourse/rfcs/pull/28">RFC #28</a>: notification resources</h2>

<p><em>Notification resources will allow you to monitor the flow of a resource through your pipeline and emit build status notifications (e.g. Slack alerts, GitHub commit status) without having to sprinkle <code class="language-plaintext highlighter-rouge">put</code> steps all over your pipeline.</em></p>

<p>Have you ever wanted to reflect your CI build status on your GitHub commits? Or send a Slack notification whenever the build is fixed or broken?</p>

<p>If so, you’re probably aware of how ugly it can make your pipelines, both in YAML and in the UI.</p>

<p>A simple pipeline quickly turns into a mess of boxes and lines:</p>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2019/07/before-notifications-1.png" class="kg-image" alt="" loading="lazy" /></figure>
<figure class="kg-card kg-image-card kg-card-hascaption"><img src=" __GHOST_URL__ /content/images/2019/07/after-notifications.png" class="kg-image" alt="" loading="lazy" /><figcaption>a simple pipeline before and after notifications were added</figcaption></figure>

<p>Not only is it a lot of manual work to copy-paste those <code class="language-plaintext highlighter-rouge">on_success</code> and <code class="language-plaintext highlighter-rouge">on_failure</code> hooks, when you finally configure it it really ruins the signal-to-noise ratio of the pipeline UI.</p>

<p>So, the plan for notification resources is to leverage <em>composition</em>, a pattern set forth in the <a href="https://github.com/concourse/rfcs/pull/24">Resources v2 RFC (#24)</a>. Instead of annotating every single job, you annotate a resource, and any time that resource is used in a build a notification will be fired, by executing the notification resource’s <code class="language-plaintext highlighter-rouge">put</code> step with the config fragment of the original resource (e.g. <code class="language-plaintext highlighter-rouge">ref: abcdef</code>) and the status of the build.</p>

<p>This way you don’t have to update all of your jobs, and notifications don’t clutter up the pipeline UI. Neato!</p>

<p>This idea is <em>also</em> a bit half-baked - follow along in <a href="https://github.com/concourse/rfcs/pull/28">RFC #28</a> when you have time!</p>

<h1 id="what-comes-after-all-this">What comes after all this?</h1>

<p>I dunno.</p>

<p>I have a lot of respect for software that is eventually considered ‘done.’ I would really like Concourse’s core design to achieve that someday.</p>

<p>We’ll always have things to improve, whether it’s through better efficiency, better UX, support for new underlying technologies (Kubernetes, Nomad), or just making our codebase more accessible for contributors. But from a core design standpoint, I think the most important thing is stability.</p>

<p>The software industry changes quickly. Hot new tools show up all the time and get replaced by newer and better tools. I don’t want our users to have to keep re-doing their CI stack just to keep up.</p>

<p>Concourse should insulate projects from the constant churn in the industry by providing a solid set of principles and abstractions that hold true regardless of the underlying technology.</p>

<p>We will continue to listen to user feedback and improve Concourse. Our goal is for it to support good patterns and prevent anti-patterns that we can identify in workflows across the industry. Thankfully patterns don’t change as frequently as tools do.</p>

<h2 id="thanks">Thanks!</h2>

<p>Everything I’ve outlined here comes from years of feedback through all of your GitHub issues, forum posts, and conversations in Discord (or Slack for you OGs). I’m very thankful for those of you that have stuck around and helped us understand your workflows, and I’m especially grateful for your patience.</p>

<p>For those of you who couldn’t wait and ultimately had to switch tools, I hope we accomplished <a href="https://github.com/concourse/docs/blob/dbf2dc1299be7c579012c2a8e8c21933890d21bb/what-and-why.scrbl#L14-L16">one of our original goals</a>, and I hope to see you back in the future!</p>


  </div><a class="u-url" href="/2019/07/17/core-roadmap-towards-v10.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Concourse Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Concourse Blog</li><li><a class="u-email" href="mailto:noreply@blog.concourse-ci.org">noreply@blog.concourse-ci.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/concourse"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">concourse</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Come Fly The Friendly CI</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

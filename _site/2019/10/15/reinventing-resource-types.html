<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Re-inventing resource types | Concourse Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Re-inventing resource types" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Before the paint completely dries on the v10 roadmap, there is one last big unknown I want to explore in case it brings more clarity to our direction: generic tasks." />
<meta property="og:description" content="Before the paint completely dries on the v10 roadmap, there is one last big unknown I want to explore in case it brings more clarity to our direction: generic tasks." />
<link rel="canonical" href="http://localhost:4000/2019/10/15/reinventing-resource-types.html" />
<meta property="og:url" content="http://localhost:4000/2019/10/15/reinventing-resource-types.html" />
<meta property="og:site_name" content="Concourse Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-10-15T15:24:13-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Re-inventing resource types" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-10-15T15:24:13-04:00","datePublished":"2019-10-15T15:24:13-04:00","description":"Before the paint completely dries on the v10 roadmap, there is one last big unknown I want to explore in case it brings more clarity to our direction: generic tasks.","headline":"Re-inventing resource types","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/10/15/reinventing-resource-types.html"},"url":"http://localhost:4000/2019/10/15/reinventing-resource-types.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Concourse Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Concourse Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Re-inventing resource types</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-10-15T15:24:13-04:00" itemprop="datePublished">Oct 15, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Before the paint completely dries on the <a href="__GHOST_URL__ /core-roadmap-towards-v10/">v10 roadmap</a>, there is one last big unknown I want to explore in case it brings more clarity to our direction: generic tasks.</p>

<p>Resource types are a great way to share tools and integrations for others to use in their pipelines. Unfortunately, they’re basically the <em>only</em> way, and because resources are a very opinionated concept, the resource type interface is not always a good fit.</p>

<p>Concurrent to this problem, there’s been a lot of talk about generic re-usable tasks. The idea is to make tasks just as easy to share and use as resource types. This would be a great alternative to resource types for workflows that don’t really fit the resource model!</p>

<p>I finally found the time to dig in to these problems, and I have two new RFCs that I’m excited to propose:</p>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/37">RFC #37: Prototypes</a></li>
  <li><a href="https://github.com/concourse/rfcs/pull/38">RFC #38: Resource Prototypes</a></li>
</ul>

<p>These proposals will have a lasting impact so I wanted to share some of my thought process here.</p>

<h2 id="what-makes-a-resource">What makes a resource?</h2>

<p>If you’ll humor me for a moment, I want to pin down what makes a resource a resource.</p>

<p>Resources are the <em>continuous</em> part of Concourse. They represent inputs changing over time, passing different versions through jobs to form a pipeline. Resources are how the continuous thing-doer knows that there are things to do: pipelines converge on the latest available versions for each job’s inputs, running builds until everything stabilizes.</p>

<p>A resource is a <strong>single object</strong> with a linear version sequence. This assumption allows Concourse pipelines to skip ahead to the latest version by default instead of having to process every single version.</p>

<p>Resources have an <strong>external source of truth</strong> ; the same resource definition will always yield the same versions, in the same order, in any pipeline, in any Concourse installation. This makes Concourse pipelines portable and self-contained, which is critical for disaster recovery.</p>

<p>Resources are <strong>immutable</strong> ; fetching the same version will always give you the same bits. This allows <code class="language-plaintext highlighter-rouge">get</code> steps to be cached so that they don’t have to be downloaded all the time.</p>

<p>Resources are <strong>idempotent</strong> ; outputs will always result in the same external effect when given the same configuration and bits. This allows for builds to be safely re-run even if some of its <code class="language-plaintext highlighter-rouge">put</code> steps already ran.</p>

<p>A resource definition looks something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resources:
- name: booklit
  type: git
  source:
    uri: https://github.com/vito/booklit
    branch: master
</code></pre></div></div>

<p>Every resource definition has a <code class="language-plaintext highlighter-rouge">type</code> and a <code class="language-plaintext highlighter-rouge">source</code>. The <em>type</em> denotes the resource type - i.e. the implementation of the <a href="https://concourse-ci.org/implementing-resource-types.html">Concourse resource interface</a> to use. The <em>source</em> represents the location of the resource, i.e. the source of versions. This configuration is interpreted by the resource type, and is a black box to Concourse.</p>

<h2 id="how-do-resource-types-work">How do resource types work?</h2>

<p>A resource type is packaged as a container image with 3 executables living under <code class="language-plaintext highlighter-rouge">/opt/resource</code>: <code class="language-plaintext highlighter-rouge">check</code>, used for finding versions, <code class="language-plaintext highlighter-rouge">in</code>, used for fetching versions, and <code class="language-plaintext highlighter-rouge">out</code>, used for writing versions. Each command reads a JSON request on <code class="language-plaintext highlighter-rouge">stdin</code> and emits a JSON response on <code class="language-plaintext highlighter-rouge">stdout</code>. These actions are run by Concourse during pipeline scheduling and build execution.</p>

<p>Concourse comes with a few “core” resource types. Some are necessary for bootstrapping, like the <code class="language-plaintext highlighter-rouge">registry-image</code> or <code class="language-plaintext highlighter-rouge">docker-image</code> resource types. Some are included just to support common use cases, like <code class="language-plaintext highlighter-rouge">git</code> and <code class="language-plaintext highlighter-rouge">time</code>. We plan to remove most of them though; it’s making the download size pretty big. (<a href="https://github.com/concourse/concourse/issues/4586">#4586</a>)</p>

<p>All other resource types must be configured in your pipeline under <code class="language-plaintext highlighter-rouge">resource_types:</code>. This makes the pipeline more self-contained, decoupling it from the resource types the Concourse installation happens to have installed.</p>

<p>Pipelines define their own resource types by configuring a resource for the type’s container image:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resource_types:
- name: git
  type: registry-image
  source:
    repository: concourse/git-resource
    tag: 1
</code></pre></div></div>

<p>Technically, resource types work by using <em>another</em> resource type to fetch their container image. It’s turtles all the way down!</p>

<p>A resource type that fits the original design of resources implements the following semantics:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">check</code> queries the external source of truth to find new versions of the object.</li>
  <li><code class="language-plaintext highlighter-rouge">in</code> reads from the external source of truth and and always produces the same bits for the same version and <code class="language-plaintext highlighter-rouge">params</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">out</code> writes to the external source of truth if necessary based on the given bits and <code class="language-plaintext highlighter-rouge">params</code>. Any version emitted by <code class="language-plaintext highlighter-rouge">out</code> can also be found by <code class="language-plaintext highlighter-rouge">check</code>.</li>
</ul>

<p>The easiest example of a ‘proper’ resource type is <code class="language-plaintext highlighter-rouge">git</code>. The <code class="language-plaintext highlighter-rouge">check</code> action consults <code class="language-plaintext highlighter-rouge">git log --first-parent</code> to return ordered commits for a single branch. The <code class="language-plaintext highlighter-rouge">in</code> action does a <code class="language-plaintext highlighter-rouge">git clone</code> to fetch the repo and check out the given commit; this is easily cached. The <code class="language-plaintext highlighter-rouge">out</code> action does a <code class="language-plaintext highlighter-rouge">git push</code>, optionally rebasing and returning a new version in the event of a conflict.</p>

<h2 id="when-is-a-resource-type-not-a-resource-type">When is a resource type not a <em>resource</em> type?</h2>
<figure class="kg-card kg-image-card kg-card-hascaption"><img src=" __GHOST_URL__ /content/images/2019/10/image-3.png" class="kg-image" alt="" loading="lazy" /><figcaption>the treachery of container images</figcaption></figure>

<p>Resource types should always implement <code class="language-plaintext highlighter-rouge">check</code> and <code class="language-plaintext highlighter-rouge">in</code>. Being able to find and fetch versions is what makes a resource a <a href="https://www.merriam-webster.com/dictionary/resource">resource</a>. Some resource types, however, only implement <code class="language-plaintext highlighter-rouge">out</code>. These resource types exist solely to be run as a <code class="language-plaintext highlighter-rouge">put</code> step - a form of “generic tasks” limited by the fact that it can’t produce any outputs local to the build.</p>

<p>Resource types should always represent a single object. This is pretty foundational to Concourse pipeline semantics. Some resource types, however, try to represent sets of objects. The easiest example is pull request resource types, which represent each pull request as a version so that you can use Concourse to run tests for all your PRs.</p>

<p>This is fraught with peril:</p>

<ul>
  <li>If you don’t set <code class="language-plaintext highlighter-rouge">version: every</code> your builds will skip pull requests because all Concourse cares about is converging on the latest version of each object. If each version is actually a different object, this assumption breaks.</li>
  <li>Because <code class="language-plaintext highlighter-rouge">version: every</code> <a href="https://github.com/concourse/concourse/issues/736">allows versions to be skipped</a> when used with <code class="language-plaintext highlighter-rouge">passed:</code> constraints, now you have to cram everything into one monolithic job. You can try to work around this by splitting it up and setting <code class="language-plaintext highlighter-rouge">serial: true</code> everywhere, but now you can’t run PRs in parallel.</li>
  <li>Pull requests can skipped if the version history shifts around in a certain way. It’s fundamentally impossible to try to represent changes to all pull requests as one version stream with a stable order, so the order jumps around all the time. If someone leaves a comment on a PR or pushes a new commit, it can get bumped to “latest” - and if a build has already run for it, the other (“older”) PRs won’t run. Even with <code class="language-plaintext highlighter-rouge">version: every</code>, Concourse won’t go <em>back in time</em> to run old versions.</li>
  <li>Navigation is awkward. The pipeline UI is pretty meaningless since all the jobs just reflect the status of the most recent PR that ran, and going through the build history of a job is pretty confusing because each build may be a different pull request.</li>
  <li>Re-running builds for a pull request is annoying. You have to go to the PR resource, find the version for your PR, pin it, trigger all the builds, wait for them all to start, and <em>then</em> you can unpin the resource, lest you forget and your pipeline never runs another PR again. This will get slightly better in v6.0 as we’ve finally implemented build re-triggering (<a href="http://github.com/concourse/concourse/issues/413">#413</a>), but that won’t help with triggering builds for an “older” PR that hasn’t run yet.</li>
</ul>

<p>This pain is the main source of motivation for the <a href="__GHOST_URL__ /core-roadmap-towards-v10/">v10 roadmap</a>, which introduces all the required components to dynamically set a pipeline for each pull request instead - each with a resource representing only one pull request, as Concourse intended.</p>

<p>In short, we have an interface being used for things beyond its original design. This results in surprising and unwanted behavior because Concourse functionality that is sensible for <em>resources</em> doesn’t make sense for these other workflows. This hurts everyone: users have to deal with surprises and terrible UX, resource type authors have to deal with these limitations and workarounds, and the concept of ‘resources’ kind of erodes as these patterns spread.</p>

<p>At this point it’s pretty clear that there’s a need to be able to share workflows and bespoke tools within the community, but it’s also clear that resources aren’t the best pipeline-level representation for all of them. So if resources aren’t a good fit, what about tasks?</p>

<h2 id="usability-of-generic-tasks">Usability of generic tasks</h2>

<p>Tasks can <em>almost</em> be packaged up and re-used as easily as resource types. I’ve been experimenting with this idea by writing <a href="https://github.com/vito/oci-build-task">a generic task for building OCI images</a>. It works by configuring <code class="language-plaintext highlighter-rouge">vito/oci-build-task</code> as the task’s image and configuring the rest of the task according to the README in the repo.</p>

<p>So far, this UX doesn’t sound that far off from using a resource type; you configure a resource type’s image in <code class="language-plaintext highlighter-rouge">resource_types:</code> and figure out how to configure the rest using its README, too. On paper, the only difference is that a task’s image is configured in <code class="language-plaintext highlighter-rouge">resources:</code> or with <code class="language-plaintext highlighter-rouge">image_resource:</code> instead.</p>

<p>Let’s compare what it looks like to take a <code class="language-plaintext highlighter-rouge">git</code> repo, build an OCI image from its <code class="language-plaintext highlighter-rouge">Dockerfile</code>, and push the image to a registry, using a generic task vs. using a resource type.</p>

<p>We’ll begin with two resources: one for my image source code, and one for the image repository on the registry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resources:
- name: my-image-src
  type: git
  source:
    uri: # ...

- name: my-image
  type: registry-image
  source:
    repository: # ...
    tag: latest
</code></pre></div></div>

<p>Next we’ll add a job that does the build-and-push.</p>

<p>Let’s see how it looks to use a generic task:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: build-and-push
  plan:
  # fetch repository source (containing Dockerfile)
  - get: my-image-src

  # build using `oci-build` task
  - task: build
    image: oci-build-task
    config:
      platform: linux
      
      image_resource:
        type: registry-image
        source:
          repository: vito/oci-build-task

      params:
        CONTEXT: my-image-src

      inputs:
      - name: my-image-src

      outputs:
      - name: image
    
      run:
        path: build

  # push using `registry-image` resource
  - put: my-image
    params: {image: image/image.tar}
</code></pre></div></div>

<p>Now let’s see how it feels to use a resource type instead. If we switch the <code class="language-plaintext highlighter-rouge">my-repo</code> resource from <code class="language-plaintext highlighter-rouge">registry-image</code> to <code class="language-plaintext highlighter-rouge">docker-image</code>, we can leverage its (<a href="https://github.com/concourse/docker-image-resource/issues/190">quite contentious</a>) build-and-push behavior:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: build-and-push
  plan:
  # fetch repository source (containing Dockerfile)
  - get: my-image-src

  # build + push using `docker-image` resource
  - put: my-image
    params:
      build: my-image-src
</code></pre></div></div>

<p>Resources clearly take a <em>lot</em> less effort to use in a pipeline. No wonder they’re being used for everything!</p>

<p>Providing a full task config is a lot of work. It allows for a lot of flexibility, but it feels verbose. Verbosity means wasting time on typos and forgotten boilerplate.</p>

<p>Verbosity aside, tasks are also strictly worse at parameterization. Task <code class="language-plaintext highlighter-rouge">params</code> are really environment variables, so every value has to be a string. This is OK for simple values, but anything more complicated will need to be marshalled and unmarshalled. This is really crummy compared to resource types, which support complex YAML/JSON config structures like lists and objects.</p>

<p>It seems like we need something in between tasks and resource types. We need something as versatile as tasks and as easy to use as resource types.</p>

<h2 id="bridging-the-gap">Bridging the gap</h2>
<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2019/10/image-1.png" class="kg-image" alt="" loading="lazy" /></figure>

<p>Let’s hone in on the reason why resource types don’t work for every use case: they have a particular set of actions which have particular semantics because they’re built for a particular Concourse use case: resources.</p>

<p>The <a href="__GHOST_URL__ /core-roadmap-towards-v10/#rfc-24-resources-v2">v10 roadmap</a> introduced <a href="https://github.com/concourse/rfcs/pull/24">RFC #24</a>, a “generalized resource” interface which supports <code class="language-plaintext highlighter-rouge">check</code>, <code class="language-plaintext highlighter-rouge">get</code>, <code class="language-plaintext highlighter-rouge">put</code>, and <code class="language-plaintext highlighter-rouge">delete</code> actions while avoiding resource terminology like “version” and “source” so that it can be used for other workflows. It’s kind of a strange middle ground: it’s limited to resource-y actions while avoiding resource-y semantics.</p>

<p>Aside from the resource-y actions, RFC #24 was pretty darn close to what I wanted out of generic tasks, so I decided to just fork it as <a href="https://github.com/concourse/rfcs/pull/37">RFC #37</a> and make one key change: instead of supporting <code class="language-plaintext highlighter-rouge">check</code>, <code class="language-plaintext highlighter-rouge">get</code>, <code class="language-plaintext highlighter-rouge">put</code>, and <code class="language-plaintext highlighter-rouge">delete</code>, support arbitrary actions instead.</p>

<p>With <code class="language-plaintext highlighter-rouge">check</code> and <code class="language-plaintext highlighter-rouge">get</code> removed, the interface was definitely not a <em>resource</em> type interface anymore. And with its support of multiple actions, it definitely wasn’t a task interface either, so I needed a new name for it.</p>

<p>After much deliberation, I decided to call these things <strong>prototypes</strong>. This name is inspired by prototype-based object-oriented languages like JavaScript, <a href="http://www.selflanguage.org/">Self</a>, and <a href="https://iolanguage.org/">Io</a>. Conveniently enough, it still has “type” in the name, so all those <code class="language-plaintext highlighter-rouge">type:</code> fields on resources still make sense!</p>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2019/10/image-2.png" class="kg-image" alt="" loading="lazy" /></figure>

<p>The next change in my fork of RFC #24 was to adjust the terminology. Now that the interface was so open-ended, I wanted to build a solid mental model so that prototype authors would have an idea of how prototypes are meant to be designed. I did this by stealing more terminology from prototype-based OOP.</p>

<p>Here’s where I landed: prototypes handle messages (previously ‘actions’) being sent to objects (previously ‘config’). In response to a message, a prototype may emit more objects (previously ‘config fragments’).</p>

<p>Thinking about Concourse as “object-oriented CI/CD” feels pretty compelling. This mental model can be easily used to describe how resource types work:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">check</code> message is sent to the <code class="language-plaintext highlighter-rouge">source</code> object to list <code class="language-plaintext highlighter-rouge">version</code> objects.</li>
  <li>The <code class="language-plaintext highlighter-rouge">get</code> message is sent to a <code class="language-plaintext highlighter-rouge">version</code> object (a <a href="https://en.wikipedia.org/wiki/Prototype-based_programming">clone</a> of the <code class="language-plaintext highlighter-rouge">source</code> object) to fetch its bits.</li>
  <li>The <code class="language-plaintext highlighter-rouge">put</code> message is sent to the <code class="language-plaintext highlighter-rouge">source</code> object to create <code class="language-plaintext highlighter-rouge">version</code> objects.</li>
</ul>

<p>Prototype implementations have full control over their domain of objects and the messages supported by those objects. For example, a <code class="language-plaintext highlighter-rouge">git</code> prototype could support multiple types of objects:</p>

<ul>
  <li>a <strong>repo</strong> object, <code class="language-plaintext highlighter-rouge">{"uri":"..."}</code>, could support <code class="language-plaintext highlighter-rouge">branches</code> to find branch objects and <code class="language-plaintext highlighter-rouge">check</code> to find commit objects in the “default” branch</li>
  <li>a <strong>branch</strong> object, <code class="language-plaintext highlighter-rouge">{"uri":"...","branch":"..."}</code>, could support <code class="language-plaintext highlighter-rouge">check</code> to find commit objects on the branch or <code class="language-plaintext highlighter-rouge">delete</code> to delete the branch</li>
  <li>a <strong>commit</strong> object, <code class="language-plaintext highlighter-rouge">{"uri":"...","branch":"...","sha":"..."}</code>, could support <code class="language-plaintext highlighter-rouge">get</code> to clone the repo and checkout the commit</li>
</ul>

<p>Over time, we can start to identify patterns and implement pipeline semantics for certain interfaces, just like we have with <code class="language-plaintext highlighter-rouge">check</code>, <code class="language-plaintext highlighter-rouge">get</code>, and <code class="language-plaintext highlighter-rouge">put</code>. For example, when a build status changes, Concourse could run the <code class="language-plaintext highlighter-rouge">notify</code> message handler for any objects in the build which support it. A <code class="language-plaintext highlighter-rouge">git</code> prototype could implement this to automatically update commit status on GitHub. This would eliminate a whole class of <code class="language-plaintext highlighter-rouge">put</code>-only resource types and de-clutter everyone’s pipelines.</p>

<h2 id="prototypes-as-generic-tasks">Prototypes as ‘generic tasks’</h2>

<p>Whereas a task is built around a single action, a prototype is built around objects which can handle messages. As such, the <code class="language-plaintext highlighter-rouge">oci-build</code> task would instead be an <code class="language-plaintext highlighter-rouge">oci-image</code> prototype supporting a <code class="language-plaintext highlighter-rouge">build</code> message.</p>

<p>Here’s how it could look to use a prototype for building an OCI image (note the use of <code class="language-plaintext highlighter-rouge">prototypes:</code> instead of <code class="language-plaintext highlighter-rouge">resource_types:</code>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prototypes:
- name: oci-image
  type: registry-image
  source:
    repository: vito/oci-image-prototype

jobs:
- name: build-and-push
  plan:
  # fetch repository source (containing Dockerfile)
  - get: my-image-src

  # build using `oci-image` prototype
  - run: build
    type: oci-image
    inputs: [my-image-src]
    params: {context: my-image-src}
    outputs: [image]

  # push using `registry-image` resource
  - put: my-image
    params: {image: image/image.tar}
</code></pre></div></div>

<p>Here we use a new  <code class="language-plaintext highlighter-rouge">run</code> step to run the <code class="language-plaintext highlighter-rouge">oci-image</code> prototype and send the  <code class="language-plaintext highlighter-rouge">build</code> message to an object, given as <code class="language-plaintext highlighter-rouge">params</code>. With the <code class="language-plaintext highlighter-rouge">run</code> step, <code class="language-plaintext highlighter-rouge">inputs</code> and <code class="language-plaintext highlighter-rouge">outputs</code> must be explicitly provided, though <code class="language-plaintext highlighter-rouge">inputs</code> can be automated in the future with <a href="https://github.com/concourse/concourse/issues/2692">#2692</a>.</p>

<p>All in all, this feels a whole lot better than the generic tasks of old. It’s way less verbose, and feels a lot like using a <code class="language-plaintext highlighter-rouge">put</code> step, with no abstractions being abused and no surprising behavior. Mission accomplished?</p>

<h2 id="how-does-this-impact-the-roadmap">How does this impact the roadmap?</h2>

<p>Through all of this, the only thing I’ve really added to the roadmap is the <code class="language-plaintext highlighter-rouge">run</code> step. Everything else is a lateral move; instead of using ‘generalized resources’ for spatial resources, notifications, and triggers, we would use ‘prototypes’ instead.</p>

<p>I think the larger impact will be on future roadmaps. With a more flexible model at our disposal we can shorten the path from identifying a common workflow and implementing richer pipeline semantics for it. Concourse becomes a “language of CI/CD,” where the objects are provided at runtime and can be shared with the community.</p>

<h2 id="how-to-get-involved">How to get involved</h2>

<p>I’m still getting a grip on this idea myself but I’m excited to see the places we can go with it. If you’d like to get involved, I could use some feedback on the RFCs!</p>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/37">RFC #37: Prototypes</a> is based on <a href="https://github.com/concourse/rfcs/pull/24">RFC #24</a>, allowing implementations to support arbitrary messages and switching everything over to prototype-based terminology. It also introduces the above <code class="language-plaintext highlighter-rouge">run</code> step for executing arbitrary message handlers.</li>
  <li><a href="https://github.com/concourse/rfcs/pull/38">RFC #38: Resource Prototypes</a> shows that prototypes which implement <code class="language-plaintext highlighter-rouge">check</code> and <code class="language-plaintext highlighter-rouge">get</code> messages can be used a resources in a pipeline, while maintaining backwards-compatibility for a smooth migration to prototype-based resources over time.</li>
</ul>

<p>If everything goes well I plan to close RFC #24 and the other ‘generalized resources’ based RFCs in favor of these new prototype-based RFCs. (I still need to write up new prototype-based RFCs for the rest though: spatial resources, notification resources, trigger-only resources.)</p>

<p>Special thanks to everyone that has helped me talk through ideas in Discord, on GitHub, and in person!</p>


  </div><a class="u-url" href="/2019/10/15/reinventing-resource-types.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Concourse Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Concourse Blog</li><li><a class="u-email" href="mailto:noreply@blog.concourse-ci.org">noreply@blog.concourse-ci.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/concourse"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">concourse</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Come Fly The Friendly CI</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-22T11:33:36-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Concourse Blog</title><subtitle>Come Fly The Friendly CI</subtitle><entry><title type="html">Running Docker in Concourse</title><link href="http://localhost:4000/2020/12/29/running-docker-in-concourse.html" rel="alternate" type="text/html" title="Running Docker in Concourse" /><published>2020-12-29T21:44:49-05:00</published><updated>2020-12-29T21:44:49-05:00</updated><id>http://localhost:4000/2020/12/29/running-docker-in-concourse</id><content type="html" xml:base="http://localhost:4000/2020/12/29/running-docker-in-concourse.html"><![CDATA[<p>So you want to run Docker in Concourse? Well this is the guide for you!</p>

<p>Let’ clarify what it is we want to do. <strong>We want to be able to run <code class="language-plaintext highlighter-rouge">docker-compose</code> inside a task in Concourse to bring up our application along side some other services (i.e. Redis, Postgres, MySQL, etc.).</strong></p>

<p>Thankfully this challenge has been solved by the community! There are a few “Docker-in-Docker” images designed to run in Concourse that are maintained by the community. Here’s a short list made from a cursory search, in no particular order:</p>

<ul>
  <li><a href="https://github.com/meAmidos/dcind">github.com/meAmidos/dcind</a></li>
  <li><a href="https://github.com/karlkfi/concourse-dcind">github.com/karlkfi/concourse-dcind</a></li>
  <li><a href="https://github.com/fhivemind/concourse-dind">github.com/fhivemind/concourse-dind</a></li>
  <li><a href="https://github.com/taylorsilva/dcind">github.com/taylorsilva/dcind</a></li>
</ul>

<p>You can also opt to build your own fork of the above images.</p>

<p>All of the above repositories have their own example pipelines that you can use to get started. What follows are some bits of information that are useful to know when using these task images.</p>

<h2 id="privileged-tasks">Privileged Tasks</h2>

<p>Running Docker inside Concourse requires the <a href="https://concourse-ci.org/jobs.html#schema.step.task-step.task">task step</a> to be <a href="https://concourse-ci.org/jobs.html#schema.step.task-step.privileged">privileged</a> because Docker needs access to the hosts cgroup filesystem in order to create containers.</p>

<p>You can verify this by looking at the bash scripts for each of the above images which all take inspiration from the <a href="https://github.com/concourse/docker-image-resource">docker-image resource</a>. Read the <a href="https://github.com/concourse/docker-image-resource/blob/babf5a7dc293102e34bd2bf93815ee3d35aac54e/assets/common.sh#L5-L48"><code class="language-plaintext highlighter-rouge">sanitize_cgroups</code> function</a> to see what exactly is being mounted from the host. (tldr: mount all cgroups as read-write)</p>

<h2 id="externalize-all-images">Externalize All Images</h2>

<p>You should avoid having Docker fetch any images from inside your task step where you are running <code class="language-plaintext highlighter-rouge">docker-compose</code>. You should externalize these as <a href="https://github.com/concourse/registry-image-resource">image resources</a> if they’re a dependency of your application (e.g. Postgres, MySQL).</p>

<p>For the container image that contains your application you should have that built in a previous <a href="https://concourse-ci.org/jobs.html#schema.step">step</a> or <a href="https://concourse-ci.org/pipelines.html#schema.pipeline.jobs">job</a>. You can <a href="__GHOST_URL__ /how-to-build-and-publish-a-container-image/">build and publish an image</a> using the <a href="https://github.com/vito/oci-build-task">oci-build task</a>.</p>

<p>To ensure Docker doesn’t try to fetch the images itself you can use <a href="https://docs.docker.com/engine/reference/commandline/load/"><code class="language-plaintext highlighter-rouge">docker load</code></a> and <a href="https://docs.docker.com/engine/reference/commandline/tag/"><code class="language-plaintext highlighter-rouge">docker tag</code></a> to load your externalized images into Docker. <a href="https://github.com/meAmidos">meAmidos’s</a> has a great <a href="https://github.com/meAmidos/dcind/blob/master/example/pipe.yml">example pipeline</a> that does exactly that.</p>

<p>meAmidos also makes two great points about why you should externalize your image:</p>

<ul>
  <li>If the image comes from a private repository, it is much easier to let Concourse pull it, and then pass it through to the task.</li>
  <li>When the image is passed to the task, Concourse can often get the image from its cache.</li>
</ul>

<p>That’s all you need to know to run Docker inside Concourse!</p>]]></content><author><name></name></author><category term="tutorials" /><summary type="html"><![CDATA[So you want to run Docker in Concourse? Well this is the guide for you!]]></summary></entry><entry><title type="html">GitOps For Your Pipelines</title><link href="http://localhost:4000/2020/08/24/gitops-for-pipelines.html" rel="alternate" type="text/html" title="GitOps For Your Pipelines" /><published>2020-08-24T14:15:00-04:00</published><updated>2020-08-24T14:15:00-04:00</updated><id>http://localhost:4000/2020/08/24/gitops-for-pipelines</id><content type="html" xml:base="http://localhost:4000/2020/08/24/gitops-for-pipelines.html"><![CDATA[<p>In this blog post we’re going to cover how to use git and Concourse to automatically set, update, and archive your pipelines using the <code class="language-plaintext highlighter-rouge">set_pipeline</code> step. No longer will you need to use <code class="language-plaintext highlighter-rouge">fly set-pipeline</code> to update any of your pipelines!</p>

<p>For consistency we will refer to the pipeline that contains all the <code class="language-plaintext highlighter-rouge">set_pipeline</code> steps as the <strong>parent pipeline</strong>. The pipelines created by the <code class="language-plaintext highlighter-rouge">set_pipeline</code> steps will be called <strong>child pipelines</strong>.</p>

<p><em>Scroll to the bottom to see the final pipeline template or <a href="https://github.com/concourse/examples/blob/master/pipelines/set-pipelines.yml">click here</a>. What follows is a detailed explanation of how the parent pipeline works along with git and automatic archiving.</em></p>

<h2 id="prerequisites">Prerequisites</h2>

<p>To run the pipelines in this blog post for yourself you can get your own Concourse running locally by following the <a href="https://concourse-ci.org/quick-start.html">Quick Start guide</a>.</p>

<p>You will also need to fork the <a href="https://github.com/concourse/examples">github.com/concourse/examples</a> repo and replace <code class="language-plaintext highlighter-rouge">USERNAME</code> with your github username in the below examples. We will continue to refer to the repo as <code class="language-plaintext highlighter-rouge">concourse/examples</code>. Once you have forked the repo clone it locally onto your machine and <code class="language-plaintext highlighter-rouge">cd</code> into the repo.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git clone git@github.com:USERNAME/examples.git
$ cd examples
</code></pre></div></div>

<h2 id="create-the-parent-pipeline">Create the Parent Pipeline</h2>

<p>Inside your fork of <code class="language-plaintext highlighter-rouge">concourse/examples</code> that you have cloned locally, create a file named <code class="language-plaintext highlighter-rouge">reconfigure-pipelines.yml</code> inside the <code class="language-plaintext highlighter-rouge">pipelines</code> folder. This is the pipeline that we are going to be building. We will refer to this pipeline as the <em>parent pipeline</em>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ touch ./pipelines/reconfigure-pipelines.yml
</code></pre></div></div>

<p>Like the <code class="language-plaintext highlighter-rouge">fly set-pipeline</code> command, the <code class="language-plaintext highlighter-rouge">set_pipeline</code> step needs a YAML file containing a pipeline configuration. We will use the concourse/examples repo as the place to store our pipelines and thankfully it already contains many pipelines! Let’s add the repo as a resource to our parent pipeline.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resources:
- name: concourse-examples
  type: git
  icon: github
  source:
    uri: git@github.com:USERNAME/examples.git
</code></pre></div></div>

<p>Now we will add a job that will set our pipelines. The first step in the job will fetch the <code class="language-plaintext highlighter-rouge">concourse/examples</code> repo, making it available to future steps as the <code class="language-plaintext highlighter-rouge">concourse-examples</code> artifact. We will also add the <code class="language-plaintext highlighter-rouge">trigger</code> parameter to ensure that the job will run whenever a new commit is pushed to the <code class="language-plaintext highlighter-rouge">concourse/examples</code> repo.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resources:
- name: concourse-examples
  type: git
  icon: github
  source:
    uri: git@github.com:USERNAME/examples.git

jobs:
- name: configure-pipelines
  public: true
  plan:
    - get: concourse-examples
      trigger: true
</code></pre></div></div>

<p>Next we will add the <code class="language-plaintext highlighter-rouge">set_pipeline</code> step to set one of the pipelines in the <code class="language-plaintext highlighter-rouge">concourse/examples</code> repo. We will set the <code class="language-plaintext highlighter-rouge">hello-world</code> pipeline first.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resources:
- name: concourse-examples
  type: git
  icon: github
  source:
    uri: git@github.com:USERNAME/examples.git

jobs:
- name: configure-pipelines
  public: true
  plan:
    - get: concourse-examples
      trigger: true
    - set_pipeline: hello-world
      file: concourse-examples/pipelines/hello-world.yml
</code></pre></div></div>

<p>Let’s commit what we have so far and push it to github.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add pipelines/reconfigure-pipelines.yml
$ git commit -m "add reconfigure-pipelines"
$ git push -u origin head
</code></pre></div></div>

<h2 id="setting-the-parent-pipeline">Setting the Parent Pipeline</h2>

<p>Now we have a <a href="https://en.wikipedia.org/wiki/Chicken_or_the_egg">chicken or the egg</a> problem, except in this case we know our parent pipeline comes first! Let’s set our pipeline with <code class="language-plaintext highlighter-rouge">fly</code> and execute the <code class="language-plaintext highlighter-rouge">configure-pipelines</code> job.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ fly -t local set-pipeline \
  -p reconfigure-pipelines \
  -c pipelines/reconfigure-pipelines.yaml

...
apply configuration? [yN]: y

$ fly -t local unpause-pipeline \
  -p reconfigure-pipelines
  
unpaused 'reconfigure-pipelines'

$ fly -t local trigger-job \
  -j reconfigure-pipelines/configure-pipelines \
  --watch
</code></pre></div></div>

<p>Once the job is done running you should see two pipelines, <code class="language-plaintext highlighter-rouge">reconfigure-pipelines</code> and <code class="language-plaintext highlighter-rouge">hello-world</code>.</p>

<figure class="kg-card kg-image-card kg-card-hascaption"><img src=" __GHOST_URL__ /content/images/2020/08/hello-world.png" class="kg-image" alt="UI showing two pipelines" loading="lazy" width="1196" height="584" srcset=" __GHOST_URL__ /content/images/size/w600/2020/08/hello-world.png 600w, __GHOST_URL__ /content/images/size/w1000/2020/08/hello-world.png 1000w, __GHOST_URL__ /content/images/2020/08/hello-world.png 1196w" sizes="(min-width: 720px) 720px" /><figcaption>dashboard showing two pipelines</figcaption></figure>

<p>Now any changes you make to the <code class="language-plaintext highlighter-rouge">hello-world</code> pipeline will be updated automatically in Concourse once it picks up the commit with your changes.</p>

<h2 id="pipelines-setting-themselves">Pipelines Setting Themselves</h2>

<p>Our parent pipeline is setting and updating one other pipeline now but it has one glaring limitation: it doesn’t set itself. We have to <code class="language-plaintext highlighter-rouge">fly set-pipeline</code> every time we want to add a new pipeline to the <code class="language-plaintext highlighter-rouge">configure-pipelines</code> job.</p>

<p>To resolve this we can do the following to our parent pipeline:</p>

<ul>
  <li>Add a job <strong>before</strong> the <code class="language-plaintext highlighter-rouge">configure-pipelines</code> job that self-updates the parent pipeline. We’ll name the job <code class="language-plaintext highlighter-rouge">configure-self</code>.</li>
  <li>Add a <code class="language-plaintext highlighter-rouge">passed</code> constraint to the <code class="language-plaintext highlighter-rouge">configure-pipelines</code> job to only run once the <code class="language-plaintext highlighter-rouge">concourse-examples</code> resource has passed the new <code class="language-plaintext highlighter-rouge">configure-self</code> job.</li>
</ul>

<p>By doing the above we will never have to use <code class="language-plaintext highlighter-rouge">fly</code> to update the parent pipline again. Every commit to the <code class="language-plaintext highlighter-rouge">concourse/examples</code> repo will cause the parent pipeline to update itself and then all of its child pipelines. Now our pipelines are following a GitOps type of workflow!</p>

<p>Here is what the above changes look like when implemented:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resources:
- name: concourse-examples
  type: git
  icon: github
  source:
    uri: git@github.com:USERNAME/examples.git

jobs:
- name: configure-self
  plan:
  - get: concourse-examples
    trigger: true
  - set_pipeline: reconfigure-pipelines
    file: concourse-examples/pipelines/reconfigure-pipelines.yml
- name: configure-pipelines
  plan:
  - get: concourse-examples
    trigger: true
    passed: [configure-self]
  - set_pipeline: hello-world
    file: concourse-examples/pipelines/hello-world.yml
</code></pre></div></div>

<p><strong>Side-note</strong> : for the <code class="language-plaintext highlighter-rouge">configure-self</code> job, you could also use the <a href="https://concourse-ci.org/jobs.html#schema.step.set-pipeline-step.set_pipeline"><code class="language-plaintext highlighter-rouge">self</code> keyword</a>, though this is labelled as experimental and may disappear in the future.</p>

<p>Lets set the parent pipeline one more time with <code class="language-plaintext highlighter-rouge">fly</code> and then we’ll make commits to the repo to make all future changes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ fly -t local set-pipeline \
  -p reconfigure-pipelines \
  -c pipelines/reconfigure-pipelines.yaml
  
...
apply configuration? [yN]: y
</code></pre></div></div>

<p>The parent pipeline should now look like this. Now the pipeline will first update itself and then update any existing child pipelines.</p>

<figure class="kg-card kg-image-card kg-card-hascaption"><img src=" __GHOST_URL__ /content/images/2020/08/set-self.png" class="kg-image" alt="parent pipeline with config-self job" loading="lazy" width="2000" height="125" srcset=" __GHOST_URL__ /content/images/size/w600/2020/08/set-self.png 600w, __GHOST_URL__ /content/images/size/w1000/2020/08/set-self.png 1000w, __GHOST_URL__ /content/images/size/w1600/2020/08/set-self.png 1600w, __GHOST_URL__ /content/images/size/w2400/2020/08/set-self.png 2400w" sizes="(min-width: 720px) 720px" /><figcaption>parent pipeline with config-self job</figcaption></figure>

<p>Let’s commit our changes, which will be a no-op since we’ve already updated the pipeline with the latest changes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add pipelines/reconfigure-pipelines.yml
$ git commit -m "add configure-self job"
$ git push
</code></pre></div></div>

<p>Now comes the real fun! To add a pipeline to Concourse all we need to do is add a <code class="language-plaintext highlighter-rouge">set_pipeline</code> step to the parent pipeline, commit it to the <code class="language-plaintext highlighter-rouge">concourse/examples</code> repo, and let the parent pipeline pick up the new commit and make the changes for us.</p>

<p>Lets add the <code class="language-plaintext highlighter-rouge">time-triggered</code> pipeline to our <code class="language-plaintext highlighter-rouge">reconfigure-pipelines.yml</code> file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resources:
- name: concourse-examples
  type: git
  icon: github
  source:
    uri: git@github.com:USERNAME/examples.git

jobs:
- name: configure-self
  plan:
  - get: concourse-examples
    trigger: true
  - set_pipeline: reconfigure-pipelines
    file: concourse-examples/pipelines/reconfigure-pipelines.yml
- name: configure-pipelines
  plan:
  - get: concourse-examples
    trigger: true
    passed: [configure-self]
  - set_pipeline: hello-world
    file: concourse-examples/pipelines/hello-world.yml
  - set_pipeline: time-triggered
    file: concourse-examples/pipelines/time-triggered.yml
</code></pre></div></div>

<p>Commit and push the changes to github.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add pipelines/reconfigure-pipelines.yml
$ git commit -m "add time-triggered pipeline"
$ git push
</code></pre></div></div>

<p>Once Concourse picks up the commit (may take up to a minute by default) you should see three pipelines on the dashboard. Now you never need to use <code class="language-plaintext highlighter-rouge">fly</code> to set pipelines!</p>

<figure class="kg-card kg-image-card kg-card-hascaption"><img src=" __GHOST_URL__ /content/images/2020/08/three-pipelines.png" class="kg-image" alt="parent and child pipelines" loading="lazy" width="1780" height="580" srcset=" __GHOST_URL__ /content/images/size/w600/2020/08/three-pipelines.png 600w, __GHOST_URL__ /content/images/size/w1000/2020/08/three-pipelines.png 1000w, __GHOST_URL__ /content/images/size/w1600/2020/08/three-pipelines.png 1600w, __GHOST_URL__ /content/images/2020/08/three-pipelines.png 1780w" sizes="(min-width: 720px) 720px" /><figcaption>parent and child pipelines</figcaption></figure>
<h2 id="detour-a-future-alternative-of-setting-pipelines">Detour: A Future Alternative of Setting Pipelines</h2>

<p>In the future there will be a different solution to setting parent pipelines: no more parent pipelines! How will Concourse eliminate the current need to start with a parent pipeline in order to set child pipelines? The answer is <a href="https://github.com/concourse/rfcs/pull/32/">RFC 32: Projects</a>.</p>

<p>If <a href="https://github.com/concourse/rfcs/pull/32/">RFC 32</a> is implemented as currently described then you won’t have to ever use <code class="language-plaintext highlighter-rouge">fly set-pipeline</code> to create pipelines, you’ll simply create a <strong>Project</strong> , which involves pointing Concourse to a repo where you code lives. In the proposed <code class="language-plaintext highlighter-rouge">project.yml</code> you can then define all of your child pipelines with <code class="language-plaintext highlighter-rouge">set_pipeline</code> steps. No need to create a parent pipeline; the <code class="language-plaintext highlighter-rouge">project.yml</code> replaces the parent pipeline and no longer requires you to have a separate job that does <code class="language-plaintext highlighter-rouge">set_pipeline: self</code>.</p>

<p>The <a href="https://github.com/concourse/rfcs/pull/32">RFC is still open</a> and looking for feedback. Check out the PR and leave your thoughts for the community to discuss!</p>

<p>Now let’s get back on track and talk about the last step in a pipeline’s lifecycle: archiving.</p>

<h2 id="automatically-archiving-pipelines">Automatically Archiving Pipelines</h2>

<p>Having Concourse automatically set pipelines for you is great but that only covers half of the lifecycle that a pipeline can go through. Some pipelines stay around forever and get continously updated. Other pipelines may only be around for a small amount of time and then be deleted or archived.</p>

<p>Thanks to <a href="https://github.com/concourse/rfcs/pull/33">RFC #33</a> you can now archive pipelines and have Concourse <strong>automatically archive</strong> pipelines for you as well. You’ve been able to archive pipelines using <code class="language-plaintext highlighter-rouge">fly</code> since Concourse 6.1.0. Automatic archiving was added in 6.5.0.</p>

<p>A pipeline will only be considered for automatic archiving if it was previously set by a <code class="language-plaintext highlighter-rouge">set_pipeline</code> step. It will be archived if one of the following is true:</p>

<ul>
  <li>the <code class="language-plaintext highlighter-rouge">set_pipeline</code> step is removed from the job</li>
  <li>the job that was setting the child pipeline is deleted</li>
  <li>the parent pipeline is deleted or archived</li>
</ul>

<p>We can test this out with the parent pipeline we were just using. Let’s remove the <code class="language-plaintext highlighter-rouge">hello-world</code> pipeline.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resources:
- name: concourse-examples
  type: git
  icon: github
  source:
    uri: git@github.com:USERNAME/examples.git

jobs:
- name: configure-self
  plan:
  - get: concourse-examples
    trigger: true
  - set_pipeline: reconfigure-pipelines
    file: concourse-examples/pipelines/reconfigure-pipelines.yml
- name: configure-pipelines
  plan:
  - get: concourse-examples
    trigger: true
    passed: [configure-self]
  - set_pipeline: time-triggered
    file: concourse-examples/pipelines/time-triggered.yml
</code></pre></div></div>

<p>Commit and push the changes to github.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add pipelines/reconfigure-pipelines.yml
$ git commit -m "remove hello-world pipeline"
$ git push
</code></pre></div></div>

<p>After a few seconds the pipeline should disappear from the dashboard (unless you toggle “show archived” on).</p>

<p>With automatic archiving the entire lifecycle of your pipelines can now be managed with a git repo and a few commits.</p>

<p>I suggest checking out the documentation for <a href="https://concourse-ci.org/jobs.html#schema.step.set-pipeline-step.set_pipeline"><code class="language-plaintext highlighter-rouge">set_pipeline</code></a> to see all the other fields available for the step, like <code class="language-plaintext highlighter-rouge">team</code> and <code class="language-plaintext highlighter-rouge">vars</code>!</p>

<h2 id="the-parent-pipeline-template-tldr">The Parent Pipeline Template (tl;dr)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resources:
- name: ci
  type: git
  icon: github
  source:
    uri: git@github.com:USERNAME/repo-where-pipelines-live.git

jobs:
- name: configure-self
  plan:
  - get: ci
    trigger: true
  - set_pipeline: self
    file: ci/path/to/parent-pipeline.yml
- name: configure-pipelines
  plan:
  - get: ci
    trigger: true
    passed: [configure-self]
  - set_pipeline: some-pipeline
    file: ci/path/to/some-pipeline.yml
  - set_pipeline: another-pipeline
    file: ci/path/to/another-pipeline.yml
`
</code></pre></div></div>]]></content><author><name></name></author><category term="tutorials" /><summary type="html"><![CDATA[In this blog post we’re going to cover how to use git and Concourse to automatically set, update, and archive your pipelines using the set_pipeline step. No longer will you need to use fly set-pipeline to update any of your pipelines!]]></summary></entry><entry><title type="html">RFC round-up: July 10th, 2020</title><link href="http://localhost:4000/2020/07/10/rfc-round-up-july-10th-2020.html" rel="alternate" type="text/html" title="RFC round-up: July 10th, 2020" /><published>2020-07-10T13:58:54-04:00</published><updated>2020-07-10T13:58:54-04:00</updated><id>http://localhost:4000/2020/07/10/rfc-round-up-july-10th-2020</id><content type="html" xml:base="http://localhost:4000/2020/07/10/rfc-round-up-july-10th-2020.html"><![CDATA[<p>Happy Friday! This one’s brief.</p>

<h2 id="merged-rfcs">Merged RFCs</h2>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/37">RFC #37: prototypes</a> has landed! …but it probably could have use more detail regarding the <code class="language-plaintext highlighter-rouge">run</code> step, which is the only immediately actionable part of it. 🤔 I’ll draft another RFC for that; #37 mainly covered the protocol.</li>
  <li><a href="https://github.com/concourse/rfcs/pull/38">RFC #38: resource prototypes</a> is in! Its associated issue for implementation is <a href="https://github.com/concourse/concourse/issues/5870">#5870</a>.</li>
</ul>

<h2 id="rfcs-to-merge">RFCs to merge</h2>

<ul>
  <li>n/a - taking a breather for this round-up to focus on the below RFCs and “reset” the 2 week merge window so I can start publishing these posts earlier in the week. 😅</li>
</ul>

<h2 id="rfcs-in-need-of-feedback">RFCs in need of feedback</h2>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/43">RFC #43: tasks queue</a> still needs some love! The goal is to introduce a queuing mechanism to resolve the long-running issue of Concourse over-working workers.</li>
  <li><a href="https://github.com/concourse/rfcs/pull/29">RFC #29: <code class="language-plaintext highlighter-rouge">across</code> step</a> introduces the special sauce for build matrices and branch/PR pipeline automation, and the proposal has been heavily revised. Check it out!</li>
</ul>

<h2 id="open-call-for-contributors">Open call for contributors</h2>

<p>Valid identifiers (<a href="https://github.com/concourse/concourse/issues/5810">#5810</a>) is now spoken for - thanks <a href="https://github.com/mouellet">@mouellet</a>! 🍻</p>

<p>The following issues are up for grabs:</p>

<ul>
  <li>Pipeline instances: <a href="https://github.com/concourse/concourse/issues/5808">#5808</a></li>
  <li>Finishing var sources: <a href="https://github.com/concourse/concourse/issues/5813">#5813</a></li>
  <li>Finishing the <code class="language-plaintext highlighter-rouge">set_pipeline</code> step: <a href="https://github.com/concourse/concourse/issues/5814">#5814</a></li>
  <li>Implementing the <code class="language-plaintext highlighter-rouge">get_var</code> step: <a href="https://github.com/concourse/concourse/issues/5815">#5815</a></li>
</ul>

<p>If anyone’s interested in helping out, or just learning how, let us know by replying to any of the issues linked above or asking in <a href="https://discord.gg/MeRxXKW">Discord</a>!</p>

<p>This section will be repeated in each RFC round-up - the goal is to get to the finish line on the v10 roadmap by tackling items in parallel while improving project health by enabling more people to make significant contributions.</p>

<p>Thanks everyone!</p>]]></content><author><name></name></author><category term="rfcs" /><summary type="html"><![CDATA[Happy Friday! This one’s brief.]]></summary></entry><entry><title type="html">RFC round-up: June 24th, 2020</title><link href="http://localhost:4000/2020/06/24/rfc-round-up-june-24th-2020.html" rel="alternate" type="text/html" title="RFC round-up: June 24th, 2020" /><published>2020-06-24T20:23:48-04:00</published><updated>2020-06-24T20:23:48-04:00</updated><id>http://localhost:4000/2020/06/24/rfc-round-up-june-24th-2020</id><content type="html" xml:base="http://localhost:4000/2020/06/24/rfc-round-up-june-24th-2020.html"><![CDATA[<p>With the four(!) RFCs from the last round-up now merged, it’s time to move on to the next RFC milestone: Prototypes!</p>

<h2 id="merged-rfcs-">Merged RFCs 🎉</h2>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/31">RFC #31: <code class="language-plaintext highlighter-rouge">set_pipeline</code> step</a></li>
  <li><a href="https://github.com/concourse/rfcs/pull/40">RFC #40: valid identifiers</a></li>
  <li><a href="https://github.com/concourse/rfcs/pull/39">RFC #39: var sources</a></li>
  <li><a href="https://github.com/concourse/rfcs/pull/27">RFC #27: var steps</a></li>
</ul>

<h2 id="rfcs-ready-to-merge-">RFCs ready to merge 🤞</h2>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/37">RFC #37: Prototypes</a> is finally ready to go! For (much) further reading, check out the <a href="__GHOST_URL__ /reinventing-resource-types/">Re-inventing resource types</a> blog post. The importance of this RFC really cannot be overstated; it will be the most significant change to Concourse since its creation.</li>
  <li><a href="https://github.com/concourse/rfcs/pull/38">RFC #38: Resource Prototypes</a> demonstrates how the Prototype protocol may be used to implement the next generation of resource prototypes (formerly resource types) and gain long-requested functionality along the way.</li>
</ul>

<h2 id="shiny-new-rfcs-">Shiny new RFCs ✨</h2>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/62">RFC #62: worker pools</a> introduces a “worker pool” which will allow a many-to-many relationship between workers and teams.</li>
  <li><a href="https://github.com/concourse/rfcs/pull/63">RFC #63: API auth flow for applications</a> is a conversation-starter around adding a token-based auth flow for read-only APIs.</li>
  <li><a href="https://github.com/concourse/rfcs/pull/61">RFC #61: add “watch” parameter for API endpoints</a> introduces a long-polling approach to API requests to reduce the load from constant polling from the web UI.</li>
</ul>

<h2 id="open-call-for-contributors-">Open call for contributors 📢</h2>

<p>The following is a list of issues for each merged RFC that still has work to be done.</p>

<ul>
  <li>Pipeline instances: <a href="https://github.com/concourse/concourse/issues/5808">#5808</a></li>
  <li>Valid identifiers: <a href="https://github.com/concourse/concourse/issues/5810">#5810</a></li>
  <li>Finishing var sources: <a href="https://github.com/concourse/concourse/issues/5813">#5813</a></li>
  <li>Finishing the <code class="language-plaintext highlighter-rouge">set_pipeline</code> step: <a href="https://github.com/concourse/concourse/issues/5814">#5814</a></li>
  <li>Implementing the <code class="language-plaintext highlighter-rouge">get_var</code> step: <a href="https://github.com/concourse/concourse/issues/5815">#5815</a></li>
</ul>

<p>If anyone’s interested in throwing their hat into the ring and getting involved with Concourse development, let us know by replying to one of the issues linked above! Future RFC round-ups will include the same list, presumably with more entries.</p>

<p>The v10 roadmap is highly parallelizeable, so if more people get involved we can make it to v10 much more quickly and with a healthier project that has more people able to contribute. We’re super keen to give guidance and help out. 👌</p>

<p>Thanks!</p>]]></content><author><name></name></author><category term="rfcs" /><summary type="html"><![CDATA[With the four(!) RFCs from the last round-up now merged, it’s time to move on to the next RFC milestone: Prototypes!]]></summary></entry><entry><title type="html">How To Build and Publish a Container Image</title><link href="http://localhost:4000/2020/06/19/how-to-build-and-publish-a-container-image.html" rel="alternate" type="text/html" title="How To Build and Publish a Container Image" /><published>2020-06-19T13:39:11-04:00</published><updated>2020-06-19T13:39:11-04:00</updated><id>http://localhost:4000/2020/06/19/how-to-build-and-publish-a-container-image</id><content type="html" xml:base="http://localhost:4000/2020/06/19/how-to-build-and-publish-a-container-image.html"><![CDATA[<p>In this blog post we are going to show how to build and publish container images using the <a href="https://github.com/vito/oci-build-task">oci-build task</a> and <a href="https://github.com/concourse/registry-image-resource">registry-image resource</a>. This post assumes you understand how to build container images with <code class="language-plaintext highlighter-rouge">Dockerfile</code>’s and publish to <a href="https://hub.docker.com/">Docker Hub</a> or another image registry using the <a href="https://docs.docker.com/engine/reference/commandline/cli/"><code class="language-plaintext highlighter-rouge">docker</code> cli</a>.</p>

<p><em>If you just want to see the pipeline, scroll to the bottom or <a href="https://github.com/concourse/examples/blob/master/pipelines/build-and-push-simple-image.yml">click here</a>. What follows is a detailed explanation of what each part of the pipeline does.</em></p>

<p>First we need a Dockerfile. You can store this in your own repo or reference the <a href="https://github.com/concourse/examples">github.com/concourse/examples</a> repo. The rest of this post assumes you use the <a href="https://github.com/concourse/examples">examples</a> repo. All files in this blog post can be found in the examples repo.</p>

<h2 id="the-dockerfile">The Dockerfile</h2>

<p>We are going to use a very basic <a href="https://github.com/concourse/examples/blob/master/Dockerfiles/simple/Dockerfile">Dockerfile</a> so we can focus on building the Concourse pipeline.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM busybox

RUN echo "I'm simple!"
COPY ./stranger /stranger
RUN cat /stranger
</code></pre></div></div>

<h2 id="defining-pipeline-resources">Defining Pipeline Resources</h2>

<p>Now we can start building out our pipeline. Let’s declare our <a href="https://concourse-ci.org/resources.html">resources</a> first. We will need one resource to pull in the repo where our Dockerfile is located, and a second resource pointing to where we want to push the built container image to.</p>

<p><em>There are some <a href="https://concourse-ci.org/pipeline-vars-example.html#variables">variables</a> in this file that we will fill out later.</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resources:
# The repo with our Dockerfile
- name: concourse-examples
  type: git
  icon: github
  source:
    uri: https://github.com/concourse/examples.git
    branch: master

# Where we will push the image to
- name: simple-image
  type: registry-image
  icon: docker
  source:
    repository: ((image-repo-name))/simple-image
    username: ((registry-username))
    password: ((registry-password))
</code></pre></div></div>

<h2 id="create-a-job">Create a Job</h2>

<p>Next we will create a <a href="https://concourse-ci.org/jobs.html">job</a> that will build and push our container image.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: build-and-push
</code></pre></div></div>

<h3 id="retrieve-the-dockerfile">Retrieve the Dockerfile</h3>

<p>The first <a href="https://concourse-ci.org/jobs.html#schema.step">step</a> in the <a href="https://concourse-ci.org/jobs.html#schema.job.plan">job plan</a> will be to retrieve the repo where our Dockerfile is.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: build-and-push
  plan:
  - get: concourse-examples
</code></pre></div></div>

<h3 id="build-the-container-image">Build the Container Image</h3>

<p>The second step in our job will build the container image.</p>

<p>To build the container image we are going to use the <a href="https://github.com/vito/oci-build-task">oci-build-task</a>. The <a href="https://github.com/vito/oci-build-task">oci-build-task</a> is a container image that is meant to be used in a Concourse <a href="https://concourse-ci.org/tasks.html">task</a> to build other container images. Check out the <a href="https://github.com/vito/oci-build-task/blob/master/README.md"><code class="language-plaintext highlighter-rouge">README</code></a> in the repo for more details on how to configure and use the <a href="https://github.com/vito/oci-build-task">oci-build-task</a> in more complex build scenarios.</p>

<p>Let’s add a <a href="https://concourse-ci.org/tasks.html">task</a> to our <a href="https://concourse-ci.org/jobs.html#schema.job.plan">job plan</a> and give it a name.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: build-and-push
  plan:
  - get: concourse-examples
  - task: build-task-image
</code></pre></div></div>

<p>All configuration of the <code class="language-plaintext highlighter-rouge">oci-build-task</code> is done through a <a href="https://concourse-ci.org/tasks.html">task config</a>. Viewing the <a href="https://github.com/vito/oci-build-task/blob/master/README.md"><code class="language-plaintext highlighter-rouge">README</code></a> from the repo we can see that the task needs to be run as a <a href="https://concourse-ci.org/jobs.html#schema.step.task-step.privileged">privileged task</a> on a linux worker.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: build-and-push
  plan:
  - get: concourse-examples
  - task: build-task-image
    privileged: true
    config:
      platform: linux
</code></pre></div></div>

<p>To use the <code class="language-plaintext highlighter-rouge">oci-build-task</code> container image we specify the <a href="https://concourse-ci.org/tasks.html#schema.task.image_resource"><code class="language-plaintext highlighter-rouge">image_resource</code></a> that the task should use.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: build-and-push
  plan:
  - get: concourse-examples
  - task: build-task-image
    privileged: true
    config:
      platform: linux
      image_resource:
        type: registry-image
        source:
          repository: vito/oci-build-task
</code></pre></div></div>

<p>Next we will add <a href="https://github.com/concourse/examples"><code class="language-plaintext highlighter-rouge">concourse-examples</code></a> as an <a href="https://concourse-ci.org/tasks.html#schema.task.inputs">input</a> to the build task to ensure the artifact from the <a href="https://concourse-ci.org/jobs.html#get-step">get step</a> (where our <code class="language-plaintext highlighter-rouge">Dockerfile</code> is fetched) is mounted in our <code class="language-plaintext highlighter-rouge">build-task-image</code> step.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: build-and-push
  plan:
  - get: concourse-examples
  - task: build-task-image
    privileged: true
    config:
      platform: linux
      image_resource:
        type: registry-image
        source:
          repository: vito/oci-build-task
      inputs:
      - name: concourse-examples
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">oci-build-task</code> <a href="https://github.com/vito/oci-build-task#outputs">outputs the built container image</a> in a directory called <code class="language-plaintext highlighter-rouge">image</code>. Let’s add <code class="language-plaintext highlighter-rouge">image</code> as an output artifact of our task so we can publish it in a later step.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: build-and-push
  plan:
  - get: concourse-examples
  - task: build-task-image
    privileged: true
    config:
      platform: linux
      image_resource:
        type: registry-image
        source:
          repository: vito/oci-build-task
      inputs:
      - name: concourse-examples
      outputs:
      - name: image
</code></pre></div></div>

<p>Next we need to tell the <code class="language-plaintext highlighter-rouge">oci-build-task</code> what the <a href="https://docs.docker.com/engine/reference/commandline/build/">build context</a> of our Dockerfile is. The <a href="https://github.com/vito/oci-build-task"><code class="language-plaintext highlighter-rouge">README</code></a> goes over a few other methods of creating your build context. We are going to use the simplest use-case. By specifying <code class="language-plaintext highlighter-rouge">CONTEXT</code> the <code class="language-plaintext highlighter-rouge">oci-build-task</code> assumes a <code class="language-plaintext highlighter-rouge">Dockerfile</code> and its build context are in the same directory.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: build-and-push
  plan:
  - get: concourse-examples
  - task: build-task-image
    privileged: true
    config:
      platform: linux
      image_resource:
        type: registry-image
        source:
          repository: vito/oci-build-task
      inputs:
      - name: concourse-examples
      outputs:
      - name: image
      params:
        CONTEXT: concourse-examples/Dockerfiles/simple
</code></pre></div></div>

<p>The last step is specifying what our <code class="language-plaintext highlighter-rouge">build-task-image</code> should execute. The <code class="language-plaintext highlighter-rouge">oci-build-task</code> container image has a binary named <a href="https://github.com/vito/oci-build-task/blob/230df3baa27fb389484ee0fb74355cd8b7977298/Dockerfile#L11"><code class="language-plaintext highlighter-rouge">build</code></a> located in its <code class="language-plaintext highlighter-rouge">PATH</code> in the <a href="https://github.com/vito/oci-build-task/blob/230df3baa27fb389484ee0fb74355cd8b7977298/Dockerfile#L15"><code class="language-plaintext highlighter-rouge">/usr/bin</code> directory</a>. We’ll tell our task to execute that binary, which will build our container image.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: build-and-push
  plan:
  - get: concourse-examples
  - task: build-task-image
    privileged: true
    config:
      platform: linux
      image_resource:
        type: registry-image
        source:
          repository: vito/oci-build-task
      inputs:
      - name: concourse-examples
      outputs:
      - name: image
      run:
        path: build
      params:
        CONTEXT: concourse-examples/Dockerfiles/simple
</code></pre></div></div>

<p>At this point in our job the container image is built! The <code class="language-plaintext highlighter-rouge">oci-build-task</code> has saved the container image as a tarball named <code class="language-plaintext highlighter-rouge">image.tar</code> in the <code class="language-plaintext highlighter-rouge">image</code> artifact specified in the task outputs. This tar file is the same output you would get if you built the container image using Docker and then did <a href="https://docs.docker.com/engine/reference/commandline/save/"><code class="language-plaintext highlighter-rouge">docker save</code></a>.</p>

<h2 id="publish-the-container-image">Publish the Container Image</h2>

<p>Now let’s push the container image to an image registry! For this example we’re pushing to <a href="https://hub.docker.com/">Docker Hub</a> using the <a href="https://github.com/concourse/registry-image-resource"><code class="language-plaintext highlighter-rouge">registry-image</code> resource</a>. You can use the <code class="language-plaintext highlighter-rouge">registry-image</code> resource to push to any image registry, private or public. Check out the <a href="https://github.com/concourse/registry-image-resource/blob/master/README.md"><code class="language-plaintext highlighter-rouge">README.md</code></a> for more details on using the resource.</p>

<p>To push the container image add a <a href="https://concourse-ci.org/jobs.html#put-step">put step</a> to our job plan and tell the regstry-image resource where the tarball of the container image is.</p>

<p>The put step will push the container image using the information defined in the resource’s <a href="https://concourse-ci.org/resources.html#schema.resource.source">source</a>, when we defined the <a href="https://concourse-ci.org/pipelines.html#schema.pipeline.resources">pipeline’s resources</a>.</p>

<p>This is where you’ll need to replace the three <a href="https://concourse-ci.org/vars.html">variables</a> found under <code class="language-plaintext highlighter-rouge">resource_types</code>. You can define them <a href="https://concourse-ci.org/vars.html#static-vars">statically</a> using <code class="language-plaintext highlighter-rouge">fly</code>’s <code class="language-plaintext highlighter-rouge">--var</code> flag when <a href="https://concourse-ci.org/setting-pipelines.html">setting</a> the pipeline. <em>(In production make sure to use a <a href="https://concourse-ci.org/creds.html">credential management system</a> to store your secrets!)</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jobs:
- name: build-and-push
  plan:
  - get: concourse-examples
  - task: build-task-image
    privileged: true
    config:
      platform: linux
      image_resource:
        type: registry-image
        source:
          repository: vito/oci-build-task
      inputs:
      - name: concourse-examples
      outputs:
      - name: image
      params:
        CONTEXT: concourse-examples/Dockerfiles/simple
      run:
        path: build
  - put: simple-image
    params:
      image: image/image.tar
</code></pre></div></div>

<h2 id="the-entire-pipeline">The Entire Pipeline</h2>

<p>Putting all the pieces together, here is our pipeline that builds and pushes (publishes) a container image.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resources:
# The repo with our Dockerfile
- name: concourse-examples
  type: git
  icon: github
  source:
    uri: https://github.com/concourse/examples.git
    branch: master

# Where we will push the image
- name: simple-image
  type: registry-image
  icon: docker
  source:
    repository: ((image-repo-name))/simple-image
    username: ((registry-username))
    password: ((registry-password))

jobs:
- name: build-and-push
  plan:
  - get: concourse-examples
  - task: build-task-image
    privileged: true
    config:
      platform: linux
      image_resource:
        type: registry-image
        source:
          repository: vito/oci-build-task
      inputs:
      - name: concourse-examples
      outputs:
      - name: image
      params:
        CONTEXT: concourse-examples/Dockerfiles/simple
      run:
        path: build
  - put: simple-image
    params:
      image: image/image.tar
</code></pre></div></div>

<p>You can set the pipeline with the following <code class="language-plaintext highlighter-rouge">fly</code> command, updating the variable values with real values the pipeline can use. The behaviour is similar to <a href="https://docs.docker.com/engine/reference/commandline/push/"><code class="language-plaintext highlighter-rouge">docker push</code></a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fly -t &lt;target&gt; set-pipeline -p build-and-push-image \
    -c ./examples/pipelines/build-and-push-simple-image.yml \
    --var image-repo-name=&lt;repo-name&gt; \
    --var registry-username=&lt;user&gt; \
    --var registry-password=&lt;password&gt;
</code></pre></div></div>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/06/build-and-publish-pipeline-3.png" class="kg-image" alt="build-and-push-pipeline" loading="lazy" width="2000" height="282" srcset=" __GHOST_URL__ /content/images/size/w600/2020/06/build-and-publish-pipeline-3.png 600w, __GHOST_URL__ /content/images/size/w1000/2020/06/build-and-publish-pipeline-3.png 1000w, __GHOST_URL__ /content/images/size/w1600/2020/06/build-and-publish-pipeline-3.png 1600w, __GHOST_URL__ /content/images/size/w2400/2020/06/build-and-publish-pipeline-3.png 2400w" sizes="(min-width: 720px) 720px" /></figure>
<h2 id="further-readings">Further Readings</h2>

<p>Understanding what the <em>build context</em> is is important when building container images. You can read <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#understand-build-context">Dockerfile Best Practices</a> for more details about <em>build contexts</em>.</p>

<p>The <a href="https://github.com/vito/oci-build-task#inputs">inputs</a> section of the oci-build-task’s <code class="language-plaintext highlighter-rouge">README</code> has examples on how to create a build context with multiple inputs and other complex build scenarios.</p>

<p>Read the <code class="language-plaintext highlighter-rouge">README</code>’s in the <a href="https://github.com/vito/oci-build-task">oci-build-task</a> and <a href="https://github.com/concourse/registry-image-resource/">registry-image resource</a> to learn more about their other configuration options.</p>

<p>If you had trouble following how the artifacts get passed between the steps of a job then read our other blog post about <a href="__GHOST_URL__ /introduction-to-task-inputs-and-outputs/">task inputs and outputs</a>.</p>]]></content><author><name></name></author><category term="tutorials" /><summary type="html"><![CDATA[In this blog post we are going to show how to build and publish container images using the oci-build task and registry-image resource. This post assumes you understand how to build container images with Dockerfile’s and publish to Docker Hub or another image registry using the docker cli.]]></summary></entry><entry><title type="html">RFC round-up: June 10th, 2020</title><link href="http://localhost:4000/2020/06/10/rfc-roundup-june-10th-2020.html" rel="alternate" type="text/html" title="RFC round-up: June 10th, 2020" /><published>2020-06-10T19:39:40-04:00</published><updated>2020-06-10T19:39:40-04:00</updated><id>http://localhost:4000/2020/06/10/rfc-roundup-june-10th-2020</id><content type="html" xml:base="http://localhost:4000/2020/06/10/rfc-roundup-june-10th-2020.html"><![CDATA[<p>First off: sorry, I immediately failed to keep my target pace for these. 😓 I got wrapped up in a deadline, and since I alternate weeks between engineering and community duties like this post, when I miss a week for RFC updates the 2-week interval can quickly turn into 4 or 5.</p>

<p>Owing to the missed round-up, and in hopes of burning through the backlog more quickly so that interested contributors may volunteer for merged RFCs, I’m going to expand the scope of this post to include more RFCs than the last one - primarily by proposing that we merge ones that are nearly certain for the <a href="__GHOST_URL__ /core-roadmap-towards-v10/">v10 roadmap</a>.</p>

<h2 id="merged-rfcs">Merged RFCs</h2>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/33">RFC #33</a> (pipeline archiving) and <a href="https://github.com/concourse/rfcs/pull/34">RFC #34</a> (pipeline instances) have both been merged! 🎉</li>
</ul>

<h2 id="rfcs-ready-to-merge">RFCs ready to merge</h2>

<p>The following RFCs have been given the <code class="language-plaintext highlighter-rouge">resolution/merge</code> label:</p>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/31">RFC #31: <code class="language-plaintext highlighter-rouge">set_pipeline</code> step</a> is the RFC corresponding to the <code class="language-plaintext highlighter-rouge">set_pipeline</code> step that was introduced experimentally in v5.8. Once this is merged, the step itself will no longer be experimental, but there <em>are</em> a couple of experimental features for the step that are now outlined in the RFC - <code class="language-plaintext highlighter-rouge">self</code> and <code class="language-plaintext highlighter-rouge">team:</code>. These features will result in warnings when used.</li>
  <li><a href="https://github.com/concourse/rfcs/pull/40">RFC #40: valid identifiers</a> proposes that we restrict the set of allowed characters in Concourse identifiers such as pipeline names, job names, and resource names. Existing pipelines and objects will be grandfathered in to ease the transition. <em>Note: if you’re worried about this change you may be interested in <a href="https://github.com/concourse/rfcs/pull/34">RFC #34</a>.</em></li>
  <li><a href="https://github.com/concourse/rfcs/pull/39">RFC #39: var sources</a> is the RFC corresponding to the <code class="language-plaintext highlighter-rouge">var_sources</code> feature, which was also introduced experimentally in v5.8. This feature is a key component to v10 - it unblocks spatial pipelines, per-job timed triggers, and per-pipeline credential management configuration.</li>
  <li><a href="https://github.com/concourse/rfcs/pull/27">RFC #27: var steps</a> is behind the <a href="https://concourse-ci.org/jobs.html#load-var-step"><code class="language-plaintext highlighter-rouge">load_var</code> step</a> (shipped experimentally in v6.0), and also introduces a <code class="language-plaintext highlighter-rouge">get_var</code> step which can theoretically be used to implement per-job trigger intervals. This RFC builds on the var sources concept described in RFC #39.</li>
</ul>

<p>Per the <a href="https://github.com/concourse/rfcs/blob/master/README.md#resolution">resolution process</a>, if there are no objections or significant changes in the 2 weeks after this post is published, they will be merged! 🚀</p>

<h2 id="rfcs-in-need-of-attention">RFCs in need of attention</h2>

<p>Quite a few RFCs have had some pretty interesting discussions or developments since the last round-up:</p>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/36">RFC #36: manual step</a> has had some juicy conversation around how things like approval and manual gating in a pipeline should be expressed in a Concoursey way - if you have thoughts on this, please chime in!</li>
  <li><a href="https://github.com/concourse/rfcs/pull/37">RFC #37: prototypes</a> is the RFC for the “Prototypes” concept introduced in the <a href="__GHOST_URL__ /reinventing-resource-types/">Re-inventing resource types</a> blog post. The latest revision introduces encryption, which will enable Prototypes to implement credential managers. If you are a resource type author or if you have a security background, please give it a look!</li>
  <li><a href="https://github.com/concourse/rfcs/pull/32">RFC #32: projects</a> now has a pretty radical new question: can Projects replace Teams in order to provide more complete cluster config automation? If you’ve ever had a need for automating team configuration, or if you have a thirst for GitOps, this should be a pretty interesting conversation!</li>
</ul>

<h2 id="new-rfcs">New RFCs</h2>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/53">RFC #53: configurable build event stores</a> proposes a pluggable architecture for build event storage as an alternative to storing them in the database.</li>
  <li><a href="https://github.com/concourse/rfcs/pull/59">RFC #59: static configuration</a> proposes a method for configuring Concourse with a config file that prescribes the teams and projects, in addition to the regular config that would previously have been set in flags or env vars. It also proposes disallowing the use of <code class="language-plaintext highlighter-rouge">fly set-team</code> at runtime so that the config is the source of truth.</li>
</ul>

<h2 id="thanks">Thanks!</h2>

<p>Giving feedback on RFCs is critical to our ability to move forward more quickly and with higher confidence. Any and all comments and questions we receive are deeply appreciated. Thanks to everyone who’s been involved, and thanks in advance to everyone else! 🙂</p>

<p>(Stay safe!)</p>]]></content><author><name></name></author><category term="rfcs" /><summary type="html"><![CDATA[First off: sorry, I immediately failed to keep my target pace for these. 😓 I got wrapped up in a deadline, and since I alternate weeks between engineering and community duties like this post, when I miss a week for RFC updates the 2-week interval can quickly turn into 4 or 5.]]></summary></entry><entry><title type="html">Introduction to Task Inputs and Outputs</title><link href="http://localhost:4000/2020/05/25/introduction-to-task-inputs-and-outputs.html" rel="alternate" type="text/html" title="Introduction to Task Inputs and Outputs" /><published>2020-05-25T13:14:40-04:00</published><updated>2020-05-25T13:14:40-04:00</updated><id>http://localhost:4000/2020/05/25/introduction-to-task-inputs-and-outputs</id><content type="html" xml:base="http://localhost:4000/2020/05/25/introduction-to-task-inputs-and-outputs.html"><![CDATA[<p>Understanding how task inputs and outputs work in Concourse can be a little confusing initially. This post will walk you through a few example pipelines to show you how inputs and outputs work within a single Concourse job. By the end you should understand how inputs and outputs work within the context of a single job.</p>

<p>Let’s define some jargon first.</p>

<ul>
  <li><strong>step</strong> : A <a href="https://concourse-ci.org/jobs.html#steps">step</a> is a container running code within the context of a Concourse job. A <a href="https://concourse-ci.org/jobs.html#steps">step</a> may have inputs and/or outputs, or neither.</li>
  <li><strong>Job plan</strong> : A list of <a href="https://concourse-ci.org/jobs.html#steps">step</a>s that a job will execute when triggered.</li>
  <li><strong>Inputs and Outputs</strong> : These are directories. Within Concourse they’re generically referred to as <strong>artifacts</strong>. These artifacts are mounted in a <strong>step</strong>’s container under a directory with <em>some-name</em>. You, as a writer of Concourse pipelines, have control over what the name of your artifacts will be. If you’re coming from the Docker world, artifact is synonymous with <a href="https://docs.docker.com/storage/volumes/">volumes</a>.</li>
</ul>

<p>To run the pipelines in the following examples yourself you can get your own Concourse running locally by following the <a href="https://concourse-ci.org/quick-start.html">Quick Start guide</a>. Then use <a href="https://concourse-ci.org/setting-pipelines.html"><code class="language-plaintext highlighter-rouge">fly set-pipeline</code></a> to see the pipelines in action.</p>

<p>Concourse pipelines contain a lot of information. Within each pipeline YAML there are comments to help bring specific lines to your attention.</p>

<h2 id="example-one---two-tasks">Example One - Two Tasks</h2>

<p>This pipeline will show us how to create outputs and pass outputs as inputs to the next <a href="https://concourse-ci.org/jobs.html#steps">step</a>(s) in a <a href="https://concourse-ci.org/jobs.html#schema.job.plan">job plan</a>.</p>

<p>This pipeline has two tasks. The first task outputs a file with the date. The second task reads and prints the contents of the file from the first task.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
jobs:
- name: a-job
  plan:
  - task: create-one-output
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: alpine}
      outputs:
        # Concourse will make an empty dir with this name
        # and save the contents for later steps
        - name: the-output
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah
            date &gt; ./the-output/file
  - task: read-ouput-from-previous-step
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: alpine}
      # You must explicitly name the inputs you expect
      # this task to have.
      # If you don't then outputs from previous steps
      # will not appear in the step's container.
      # The name must match the output from the previous step.
      # Try removing or renaming the input to see what happens!
      inputs:
        - name: the-output
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah
            cat ./the-output/file
</code></pre></div></div>

<p>Here’s a visual graphic of what happens when the above job is executed.</p>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/example-one-10.gif" class="kg-image" alt="" loading="lazy" /></figure>
<h2 id="example-two---two-tasks-with-the-same-output-who-wins">Example Two - Two tasks with the same output, who wins?</h2>

<p>This example is to satisfy the curiosity cat inside all of us! Never do this in real life because you’re definitely going to hurt yourself!</p>

<p>There are two jobs in this pipeline. The first job has two <a href="https://concourse-ci.org/jobs.html#steps">step</a>s; both steps will produce an artifact named <code class="language-plaintext highlighter-rouge">the-output</code> in parallel. If you run the <code class="language-plaintext highlighter-rouge">writing-to-the-same-output-in-parallel</code> job multiple times you’ll see the file in <code class="language-plaintext highlighter-rouge">the-output</code> folder changes depending on which of the parallel tasks finished last. Here’s a visualization of the first job.</p>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/example-two-parallel.gif" class="kg-image" alt="" loading="lazy" /></figure>

<p>The second job is a serial version of the first job. In this job the second task always wins because it’s the last task that outputs <code class="language-plaintext highlighter-rouge">the-output</code>, so only <code class="language-plaintext highlighter-rouge">file2</code> will be in <code class="language-plaintext highlighter-rouge">the-output</code> directory in the last <a href="https://concourse-ci.org/jobs.html#steps">step</a> in the <a href="https://concourse-ci.org/jobs.html#schema.job.plan">job plan</a>.</p>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/example-two-serial.gif" class="kg-image" alt="" loading="lazy" /></figure>

<p>This pipeline illustrates that you could accidentally overwrite the output from a previous <a href="https://concourse-ci.org/jobs.html#steps">step</a> if you’re not careful with the names of your outputs.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
jobs:
- name: writing-to-the-same-output-in-parallel
  plan:
  # running two tasks that output in parallel?!?
  # who will win??
  - in_parallel:
    - task: create-the-output
      config:
        platform: linux
        image_resource:
          type: registry-image
          source: {repository: busybox}
        outputs:
          - name: the-output
        run:
          path: /bin/sh
          args:
            - -cx
            - |
              ls -lah
              date &gt; ./the-output/file1
    - task: also-create-the-output
      config:
        platform: linux
        image_resource:
          type: registry-image
          source: {repository: busybox}
        outputs:
          - name: the-output
        run:
          path: /bin/sh
          args:
            - -cx
            - |
              ls -lah
              date &gt; ./the-output/file2
  # run this job multiple times to see which
  # previous task wins each time
  - task: read-ouput-from-previous-step
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      inputs:
        - name: the-output
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah ./the-output
            echo "Get ready to error!"
            cat ./the-output/file1 ./the-output/file2

- name: writing-to-the-same-output-serially
  plan:
  - task: create-one-output
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      outputs:
        - name: the-output
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah
            date &gt; ./the-output/file1
  - task: create-another-output
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      outputs:
        - name: the-output
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah
            date &gt; ./the-output/file2
  - task: read-ouput-from-previous-step
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      inputs:
        - name: the-output
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah ./the-output
            echo "Get ready to error!"
            cat ./the-output/file1 ./the-output/file2
</code></pre></div></div>

<h2 id="example-three---inputoutput-name-mapping">Example Three - Input/Output Name Mapping</h2>

<p>Sometimes the names of inputs and outputs don’t match, or they do match and you don’t want them overwriting each other, like in the previous example. That’s when <a href="https://concourse-ci.org/jobs.html#schema.step.task-step.input_mapping"><code class="language-plaintext highlighter-rouge">input_mapping</code></a> and <a href="https://concourse-ci.org/jobs.html#schema.step.task-step.output_mapping"><code class="language-plaintext highlighter-rouge">output_mapping</code></a> become helpful. Both of these features map the inputs/outputs in the task’s config to some artifact name in the <a href="https://concourse-ci.org/jobs.html#schema.job.plan">job plan</a>.</p>

<p>This pipeline has one job with four tasks.</p>

<p>The first task outputs a file with the date to the <code class="language-plaintext highlighter-rouge">the-output</code> directory. <code class="language-plaintext highlighter-rouge">the-output</code> is mapped to the new name <code class="language-plaintext highlighter-rouge">demo-disk</code>.  The artifact <code class="language-plaintext highlighter-rouge">demo-disk</code> is now available in the rest of the <a href="https://concourse-ci.org/jobs.html#schema.job.plan">job plan</a> for future <a href="https://concourse-ci.org/jobs.html#steps">step</a>s to take as inputs. The remaining steps do this in various ways.</p>

<p>The second task reads and prints the contents of the file under the new name <code class="language-plaintext highlighter-rouge">demo-disk</code>.</p>

<p>The third task reads and prints the contents of the file under another name, <code class="language-plaintext highlighter-rouge">generic-input</code>. The <code class="language-plaintext highlighter-rouge">demo-disk</code> artifact in the <a href="https://concourse-ci.org/jobs.html#schema.job.plan">job plan</a> is mapped to <code class="language-plaintext highlighter-rouge">generic-input</code>.</p>

<p>The fourth task tries to use the artifact named <code class="language-plaintext highlighter-rouge">the-output</code> as its input. This task fails to even start because there was no artifact with the name <code class="language-plaintext highlighter-rouge">the-output</code> available in the <a href="https://concourse-ci.org/jobs.html#schema.job.plan">job plan</a>; it was remapped to <code class="language-plaintext highlighter-rouge">demo-disk</code>.</p>

<p>Here’s a visualization of the job.</p>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/example-three-1.gif" class="kg-image" alt="" loading="lazy" /></figure>

<p>Here’s the pipeline YAML for you to run on your local Concourse.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
jobs:
- name: a-job
  plan:
  - task: create-one-output
    # The task config has the artifact `the-output`
    # output_mapping will rename `the-output` to `demo-disk`
    # in the rest of the job's plan
    output_mapping:
      the-output: demo-disk
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      outputs:
        - name: the-output
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah
            date &gt; ./the-output/file
  # this task expects the artifact `demo-disk` so no mapping is needed
  - task: read-ouput-from-previous-step
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      inputs:
        - name: demo-disk
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah
            cat ./demo-disk/file
  - task: rename-and-read-output
    # This task expects the artifact `generic-input`.
    # input_mapping will map the tasks `generic-input` to
    # the job plans `demo-disk` artifact
    input_mapping:
      generic-input: demo-disk
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      inputs:
        - name: generic-input
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah
            cat ./generic-input/file
  - task: try-and-read-the-output
    input_mapping:
      generic-input: demo-disk
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      # `the-output` is not available in the job plan
      # so this task will error while initializing
      # since there's no artiact named `the-output` in
      # the job's plan
      inputs:
        - name: the-output
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah
            cat ./generic-input/file
</code></pre></div></div>

<h2 id="example-four---can-you-add-files-to-an-existing-output-artifact">Example Four - Can you add files to an existing output artifact?</h2>

<p>This pipeline will also have two jobs in order to illustrate this point. What happens if we add a file to an output? If you think back to example two you may already know the answer.</p>

<p>The first task will create <code class="language-plaintext highlighter-rouge">the-output</code> with <code class="language-plaintext highlighter-rouge">file1</code>. The second task will add <code class="language-plaintext highlighter-rouge">file2</code> to the <code class="language-plaintext highlighter-rouge">the-output</code>. The last task will read the contents of <code class="language-plaintext highlighter-rouge">file1</code> and <code class="language-plaintext highlighter-rouge">file2</code>.</p>

<p>As long as you re-declare the input as an output in the second task you can modify any of your outputs.</p>

<p>This means you can pass something between a bunch of tasks and have each task add or modify something in the artifact.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
jobs:
- name: add-file-to-output
  plan:
  - task: create-one-output
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      outputs:
        - name: the-output
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah
            date &gt; ./the-output/file1
  - task: add-file-to-previous-output
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      # this task lists the same artifact as
      # its input and output
      inputs:
        - name: the-output
      outputs:
        - name: the-output
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah
            date &gt; ./the-output/file2
  - task: read-ouput-from-previous-step
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      inputs:
        - name: the-output
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah ./the-output
            cat ./the-output/file1 ./the-output/file2
</code></pre></div></div>

<p>Here’s a visualization of the job.</p>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/example-four.gif" class="kg-image" alt="" loading="lazy" /></figure>
<h2 id="example-five---multiple-outputs">Example Five - Multiple Outputs</h2>

<p>What happens if you have a task that has multiple outputs and a second task that only lists one of the outputs? Does the second task get the extra outputs from the first task?</p>

<p>The answer is no. A task will only get the artifacts that match the name of the inputs listed in the task’s config.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
jobs:
- name: multiple-outputs
  plan:
  - task: create-three-outputs
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      outputs:
        - name: the-output-1
        - name: the-output-2
        - name: the-output-3
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah
            date &gt; ./the-output-1/file
            date &gt; ./the-output-2/file
            date &gt; ./the-output-3/file
  - task: take-one-output
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      # only one of the three outputs are
      # listed as inputs
      inputs:
        - name: the-output-1
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah ./
            cat ./the-output-1/file
  - task: take-two-outputs
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      # this task pulls in the other
      # two outputs, just for fun!
      inputs:
        - name: the-output-2
        - name: the-output-3
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah ./
            cat ./the-output-2/file
            cat ./the-output-3/file
</code></pre></div></div>

<p>Here’s a visualization of the above job.</p>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/example-five.gif" class="kg-image" alt="" loading="lazy" /></figure>
<h2 id="example-six---get-steps">Example Six - Get Steps</h2>

<p>The majority of Concourse pipelines have at least one resource, which means they have at least one <a href="https://concourse-ci.org/jobs.html#get-step">get step</a>. Using a get step in a job makes an artifact with the name of the get step available for later steps in the <a href="https://concourse-ci.org/jobs.html#schema.job.plan">job plan</a> to consume as inputs.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
resources:
- name: concourse-examples
  type: git
  source: {uri: "https://github.com/concourse/examples"}

jobs:
- name: get-step
  plan:
  # there will be an artifact named
  # "concourse-examples" available in the job plan
  - get: concourse-examples
  - task: take-one-output
    config:
      platform: linux
      image_resource:
        type: registry-image
        source: {repository: busybox}
      inputs:
        - name: concourse-examples
      run:
        path: /bin/sh
        args:
          - -cx
          - |
            ls -lah ./
            cat ./concourse-examples/README.md
</code></pre></div></div>

<p>Here’s a visualization for the above job.</p>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/example-six.gif" class="kg-image" alt="" loading="lazy" /></figure>

<p>I hope you found these example helpful with figuring out how inputs and outputs work within a single Concourse job.</p>]]></content><author><name></name></author><category term="tutorials" /><summary type="html"><![CDATA[Understanding how task inputs and outputs work in Concourse can be a little confusing initially. This post will walk you through a few example pipelines to show you how inputs and outputs work within a single Concourse job. By the end you should understand how inputs and outputs work within the context of a single job.]]></summary></entry><entry><title type="html">Concourse 2020 Community Report</title><link href="http://localhost:4000/2020/05/14/community-survey-2020-results.html" rel="alternate" type="text/html" title="Concourse 2020 Community Report" /><published>2020-05-14T18:41:54-04:00</published><updated>2020-05-14T18:41:54-04:00</updated><id>http://localhost:4000/2020/05/14/community-survey-2020-results</id><content type="html" xml:base="http://localhost:4000/2020/05/14/community-survey-2020-results.html"><![CDATA[<p>A little over a month ago, the Concourse team sent a survey out to the community. The purpose of this survey was to gain insight into our users as well as measure our year-over-year growth. In the process of learning about how you all deploy and manage Concourse, we also received tons of great feedback about what’s working well and what needs work in order to make Concourse even better. We’re excited to share our findings!</p>

<p>A huge thank you to everyone who responded. At the time of this writing, we’ve received over 100 responses and that number is still climbing. Your contributions are valuable, and learning about how different segments of our user base works with our product is going to help us make Concourse even better in 2020!</p>

<h2 id="feature-requests-areas-to-improve"><strong>Feature requests, areas to improve</strong></h2>

<h3 id="configuration-️"><strong>Configuration ⚙️</strong></h3>

<p>This is a big one. The community wants more control for administrators and operators, more options for integrations, and more power over resource types configuration. We also learned a lot about the specific ways Concourse is making life more difficult than it needs to be in terms of configuring tasks, pipelines, teams, and the product itself.</p>

<p>Code and configuration duplication is a serious issue, and our users want more powerful templating tools to help them split pipeline configuration into more manageable chunks that will be easier to reason about and maintain.</p>

<p>In addition, there’s a lot of support for concepts covered by our <a href="https://github.com/concourse/rfcs/pull/34">Instanced Pipelines</a>, <a href="https://github.com/concourse/rfcs/pull/29">Spatial Resources</a>, and other major architectural ideas that we have prioritized for 2020.</p>

<p>We’re also paying particular attention to the number of responses that were focused on git integration and GitOps workflows. If you have a way of using Concourse that you feel isn’t well represented by the current featureset or CLI/UI, please <a href="https://twitter.com/concourseci">@mention us on Twitter</a> or <a href="https://discord.gg/MeRxXKW">drop by Discord</a> and tell us about it.</p>

<h3 id="web-ui-"><strong>Web UI  🖥</strong></h3>

<p>Concourse’s web UI is a hot topic! While most of the web UI feedback is positive, there are lots of suggestions on how to improve it or what to add next. Feedback from the survey about the web UI could make for its own blog post, so in the interest of being brief, I’m just going to touch lightly on the strongest signals/insights that were generated.</p>

<p>A number of respondents called to attention the ease of use and clarity of information in the current UI. While we’ve been continuously iterating to add text labels instead of just icons where possible, and to add clarifying tooltips elsewhere, there’s clearly a need for more. In addition to several smaller tweaks, we have work underway around adding the minimum viable <a href="https://github.com/concourse/concourse/issues/5434">Favorite Pipelines</a> functionality that will be built upon to extend the <a href="https://github.com/concourse/concourse/issues/5434">Archiving Pipelines</a> functionality introduced in v6.1.0 to the front end. Hopefully these fixes will make a big impact, decluttering Concourse dashboards and making it a lot faster to find what you want at the same time.</p>

<p>Another area where we can clearly improve is by adding more detail to the dashboard. Users are requesting more options for adding notes, tracking an audit trail of actions in the UI, clearer and more detailed error messages, and more statistical information like build duration and lead times. We’ll be looking at the possibilities in this space over the coming months. If you have ideas, start a <a href="https://github.com/concourse/concourse/discussions">Discussion on Github</a>.</p>

<h3 id="runtime-improvements-"><strong>Runtime Improvements 📈</strong></h3>

<p>In addition to more stability and performance, the community puts a high level of importance and value on improving the efficient use of check containers, global locks on resource checking, and the ability to clear cached resource versions of a worker on demand with <em>fly</em>.</p>

<h3 id="docker-enhancements-and-performance-"><strong>Docker Enhancements and Performance 💨</strong></h3>

<p>We hear you. 😀</p>

<p>Comments from the community emphasized optimizing docker-image resources, facilitating docker in worker containers, and better reporting on docker image status. There are a number of different voices in this conversation all with very different strategies for how they use Concourse, and we’re sorting through feedback to help us prioritize low hanging fruit and high value enhancements that the team can prioritize.</p>

<p>Additionally, we’re actively monitoring issues and continuously collecting data on Docker performance so that we can make more improvements - we understand that every last bit of performance we can squeeze out of Docker interactions results in a huge benefit to many of our users.</p>

<h3 id="stability-kubernetes-documentation-️--"><strong>Stability, Kubernetes, Documentation ⚖️ 🚢 📚</strong></h3>

<p>These issues have remained top of mind in the community for the past few years, and this year’s survey is no exception. From a stability perspective, the team has made great strides with the release of the new algorithm in <a href="https://github.com/concourse/concourse/releases/tag/v6.0.0">version 6.0.0</a>. The team has also taken further steps into being more k8s native by beginning an ongoing track of work dedicated to running K8s workloads. And lastly, our documentation work is ongoing - we hope to prioritize more ‘getting started’ materials for  beginners in order to enable new users to climb the learning curve faster than before. For more advanced users, we also plan more documentation around topics like autoscaling, tracing, and build statistics, among others.</p>

<h2 id="demographic-data"><strong>Demographic Data</strong></h2>

<h3 id="how-long-have-you-used-concourse"><strong>How long have you used Concourse?</strong></h3>
<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/Screen-Shot-2020-05-14-at-11.24.35-AM-1.png" class="kg-image" alt="" loading="lazy" /></figure>

<p>Most of the people who responded indicated they had been using Concourse for one year or less. It’s great to see that more people are picking up and experimenting with Concourse with each new release, and it’s just as exciting to see that people stick around: more than 45% of respondents said they have been using Concourse for <strong>2+ years</strong>. Whenever we interpret feedback from the community, we want to make sure we’re taking into account the experiences of both newcomers, established users, and very experienced power users. Each segment experiences different challenges, and prioritizes different parts of the product.</p>

<h3 id="other-ci-cd-tools-used"><strong>Other CI CD tools used</strong></h3>
<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/Screen-Shot-2020-05-14-at-11.24.03-AM-1.png" class="kg-image" alt="" loading="lazy" /></figure>

<p>Another dimension that’s helpful to understand is the related experiences that each survey respondent is equipped with. When looking at other CI/CD tools that our community employs, <strong>Jenkins</strong> is still the top dog, accounting for nearly 30% of the tools mentioned. <strong>Github Actions</strong> has seen a rise in adoption since its initial release, and Travis, Gitlab, Bitbucket, and CircleCI are all fairly common options as well.</p>

<h3 id="how-did-you-find-out-about-concourse"><strong>How did you find out about Concourse?</strong></h3>
<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/Screen-Shot-2020-05-14-at-11.22.53-AM.png" class="kg-image" alt="" loading="lazy" /></figure>

<p>Pivotal Software (now VMware) has been Concourse’s largest supporter since the project’s inception. In previous years, it was common to see more than half of respondents say they were introduced to Concourse CI through a Pivotal Labs engagement, or through Concourse’s role in automation of the Pivotal Platform, Pivotal <a href="https://www.cloudfoundry.org/">Cloud Foundry</a>. Now the community has started to branch out, with only 22% of people reporting that they learned about the product through Pivotal.</p>

<p>The majority of users seem to have found Concourse organically, through search engines or social media. We’re hoping to expand the use of our blog this year to help support the number of people hunting for Concourse content. Be on the lookout for more tutorials, advanced operations articles, and general updates about the Concourse product development and roadmap.</p>

<p>We’d love to grow that <em>Conference or Meetup</em> section in 2020 - who’s up for a remote meetup over Zoom? 🙌</p>

<h3 id="why-use-concourse"><strong>Why use Concourse?</strong></h3>
<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/Screen-Shot-2020-05-14-at-11.24.16-AM.png" class="kg-image" alt="" loading="lazy" /></figure>

<p>When asked about the very important _ <strong>why</strong> _ behind their Concourse usage, concerns about <strong>Open Source</strong> tooling and <strong>flexibility</strong> were top of mind. The special emphasis that Concourse put on <strong>reproducibility</strong> and <strong>user interface</strong> also ranked highly, along with Concourse’s <strong>scalability</strong> and overall feature set. Scalability is always a huge concern for the team, as we see enterprise customers frequently testing the limits of their tooling (sometimes with hundreds of Concourse clusters, many thousands of teams, and many <em>hundreds of thousands</em> of pipelines). Likewise, reproducibility is a commitment we’re not planning on straying from any time soon.</p>

<h3 id="concourse-versions"><strong>Concourse Versions</strong></h3>
<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/Screen-Shot-2020-05-14-at-11.53.24-AM.png" class="kg-image" alt="" loading="lazy" /></figure>

<p>We released the survey <em>just</em> as v6.0.0 of Concourse was being finalized, so it was only close to the end that we started to see people upgrading to v6. We’re thrilled, nonetheless, to see so many people had already upgraded to v5.8.x. Together, versions v5.8.x and v5.7.x represented the majority of survey respondents, with a low (&gt;10) rate of responses for any other version.</p>

<p>To those 12 users who are still on v4.x.x and 7 users still on v3.x.x, feel free to<a href="https://discord.gg/MeRxXKW">get in touch on the Concourse Discord</a> if you need any help upgrading! You can find all of the wonderful reasons to upgrade in the<a href="https://github.com/concourse/concourse/releases">release notes</a>, and we’ll write blog articles in the coming months highlighting some of the latest and greatest new features and optimizations, as well as some upcoming enhancements on our roadmap.</p>

<h3 id="scale"><strong>Scale</strong></h3>
<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/Screen-Shot-2020-05-14-at-11.23.29-AM.png" class="kg-image" alt="" loading="lazy" /></figure>

<p>The data gathered shows that the majority of respondents are working with Concourses organized with fewer teams. And when it comes to users…</p>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/Screen-Shot-2020-05-14-at-11.23.48-AM.png" class="kg-image" alt="" loading="lazy" /></figure>

<p>… we see a lot of smaller Concourse instances of under 10 users. There are also a few examples of large, enterprise scale deployments of 100+ users over 50+ teams. On the Concourse team, we frequently reach out to enterprise customers for special feedback on more massive implementation concerns. We also survey and interview members of the open source community to make sure we’re building solutions that scale <em>down</em> to single users and small teams.</p>

<p>If you’d like to add your voice, feel free to join in on the<a href="https://github.com/concourse/concourse/discussions">Concourse Discussions</a> board.</p>

<h3 id="deployment-method"><strong>Deployment Method</strong></h3>
<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/Screen-Shot-2020-05-14-at-11.22.23-AM.png" class="kg-image" alt="" loading="lazy" /></figure>

<p><strong>Docker</strong> remains the most frequently used deployment method, but the margins are slowly shrinking, and there’s more even distribution across other popular options than we’ve seen in past years.</p>

<p>Nearly identical numbers of responses came in citing <strong>Kubernetes</strong> (via the Helm chart), <strong>BOSH</strong> , and <strong>VM</strong> deployment strategies, reinforcing both our interest in facilitating K8s workflows and supporting our substantial BOSH user base.</p>

<h3 id="concourse-usage-style"><strong>Concourse Usage Style</strong></h3>
<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/Screen-Shot-2020-05-14-at-11.24.53-AM.png" class="kg-image" alt="" loading="lazy" /></figure>

<p>This year we asked about our users’ usage style - specifically, what sort of development scenarios they were using Concourse to facilitate. Concourse remains an <strong>Infrastructure Automation</strong> powerhouse, and a similar number of users are using it to perform <strong>CI for web development</strong> and <strong>deploying software</strong> as part of their <strong>path to production</strong>.</p>

<h3 id="workloads"><strong>Workloads</strong></h3>
<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/Screen-Shot-2020-05-14-at-11.57.17-AM.png" class="kg-image" alt="" loading="lazy" /></figure>

<p><strong>Linux workloads</strong> represent the vast majority for the Concourse community. We’re also paying attention to special concerns for those running <strong>Windows</strong> and <strong>Darwin</strong> workloads, however this knowledge will help us prioritize fixes to help the largest group of users possible.</p>

<h3 id="preferred-iaas"><strong>Preferred IAAS</strong></h3>
<figure class="kg-card kg-image-card kg-card-hascaption"><img src=" __GHOST_URL__ /content/images/2020/05/Screen-Shot-2020-05-14-at-1.10.07-PM.png" class="kg-image" alt="" loading="lazy" /><figcaption>Note: RMDH is remotely-managed dedicated hardware</figcaption></figure>

<p>Finally, when asked about their preferred IAAS, <strong>AWS</strong> takes the top position again for the third year in a row. We consistently see a strong vSphere presence from enterprise customers, but it’s really interesting to see the variety of setups that the open source community as a whole employs when deploying Concourse.</p>

<h2 id="summary"><strong>Summary</strong></h2>

<p>A recurring topic that comes up in conversations with customers and internal teams at VMware is the sheer variety of ways that Concourse can be set up and put to work. Running this survey further reinforces that idea, giving us insight into an even larger number of configurations and implementations than what we see during our day to day enterprise development and support.</p>

<p>It’s also interesting to reflect on how far the project has come since Concourse CI was first introduced. We’re nearing 22k commits from over 318 contributors adding up to 333 releases as of the typing of this sentence, and we’re looking forward to speeding up even further in 2020.</p>

<p>Of course, we want to make sure that we’re developing the right features, prioritizing the right fixes and enhancements, and validating that each step we take has been made in the right direction. In the upcoming months we’ll be consolidating all of these ideas into a new high level roadmap that sets out quarterly milestones for the team.</p>

<p>Keep watch on the <a href="https://github.com/concourse/concourse/discussions">Github discussions page</a>, this blog, and <a href="https://twitter.com/concourseci">the Concourse Twitter feed</a> for more updates, and don’t forget to<a href="https://discord.gg/MeRxXKW">join the conversation on Discord</a>.</p>]]></content><author><name></name></author><category term="design" /><summary type="html"><![CDATA[A little over a month ago, the Concourse team sent a survey out to the community. The purpose of this survey was to gain insight into our users as well as measure our year-over-year growth. In the process of learning about how you all deploy and manage Concourse, we also received tons of great feedback about what’s working well and what needs work in order to make Concourse even better. We’re excited to share our findings!]]></summary></entry><entry><title type="html">RFC round-up: May 6th, 2020</title><link href="http://localhost:4000/2020/05/06/rfc-roundup-may-6th-2020.html" rel="alternate" type="text/html" title="RFC round-up: May 6th, 2020" /><published>2020-05-06T17:34:37-04:00</published><updated>2020-05-06T17:34:37-04:00</updated><id>http://localhost:4000/2020/05/06/rfc-roundup-may-6th-2020</id><content type="html" xml:base="http://localhost:4000/2020/05/06/rfc-roundup-may-6th-2020.html"><![CDATA[<p>Howdy, and welcome to our first RFC round-up! 🤠</p>

<figure class="kg-card kg-image-card"><img src=" __GHOST_URL__ /content/images/2020/05/image.png" class="kg-image" alt="" loading="lazy" /></figure>

<p>For those unaware, <a href="https://github.com/concourse/rfcs#concourse-rfcs">Concourse RFCs</a> are a process for proposing and collaborating on improvements to core Concourse functionality, including pipeline behavior, new step types, new operator capabilities, etc.</p>

<p>In short, RFCs are where all the <em>cool new stuff</em> is planned. 😎</p>

<p>My goal is to provide an update at least every few weeks on the status of RFCs and shepherd them through the process via blog posts like this one. Each post will be limited to a handful of RFCs in order to focus our energy and not overwhelm readers.</p>

<h2 id="rfcs-ready-to-merge">RFCs ready to merge</h2>

<p>The following RFCs have been given the <code class="language-plaintext highlighter-rouge">resolution/merge</code> label:</p>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/33">RFC #33: archiving pipelines</a> proposes that pipelines can be “archived” - effectively a soft-delete, or perhaps a long-pause. This RFC is ready to go, and in fact we’ve already started to implement it. It will be an experimental opt-in feature until this RFC is merged.</li>
  <li><a href="https://github.com/concourse/rfcs/pull/34">RFC #34: pipeline instances</a> proposes a mechanism for grouping related pipelines together under a single identifier, further breaking down each instance by a set of associated vars.</li>
</ul>

<p>Both of these RFCs are key components to our plan for Git branch/PR pipeline automation, as described in the <a href="__GHOST_URL__ /core-roadmap-towards-v10/">v10 blog post</a>.</p>

<p>Per the <a href="https://github.com/concourse/rfcs/blob/master/README.md#resolution">resolution process</a>, if there are no objections or significant changes in the 2 weeks after this post is published, they will be merged! 🚀</p>

<h2 id="rfcs-in-need-of-specific-feedback">RFCs in need of specific feedback</h2>

<p>These two RFCs are nearing completion, but have some outstanding questions:</p>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/39">RFC #39: var sources</a> is the RFC behind the <a href="https://concourse-ci.org/vars.html#var-sources">experimental <code class="language-plaintext highlighter-rouge">var_sources:</code> feature</a> introduced in v5.8.0. The main question is around whether and how it may be used to replace the cluster-wide credential manager configuration.</li>
  <li><a href="https://github.com/concourse/rfcs/pull/31">RFC #31: <code class="language-plaintext highlighter-rouge">set_pipeline</code> step</a> is mostly implemented already, also <a href="https://concourse-ci.org/jobs.html#schema.step.set-pipeline-step.set_pipeline">shipped experimentally</a> in v5.8.0. The remaining question is around whether to support <code class="language-plaintext highlighter-rouge">set_pipeline: self</code> - this is a point of contention as there may be a better pattern for that sort of thing in the future (<a href="https://github.com/concourse/rfcs/pull/32">hint</a>).</li>
</ul>

<p>Lend us your opinions!</p>

<h2 id="rfcs-in-need-of-attention">RFCs in need of attention</h2>

<p>These ones just need more eyes on’em:</p>

<ul>
  <li><a href="https://github.com/concourse/rfcs/pull/43">RFC #43: task queue</a> proposes a “Resource Pool” mechanism with the end goal of fixing the age-old problem of Concourse overloading workers. If you’ve run into this before and you’d like to see it fixed, this is your chance to get involved!</li>
  <li><a href="https://github.com/concourse/rfcs/pull/41">RFC #41: OPA integration</a> proposes support for policy enforcement through <a href="https://www.openpolicyagent.org/">Open Policy Agent</a>, which would allow access control to be delegated to an external OPA endpoint. Neat!</li>
</ul>

<h2 id="wrapping-up">Wrapping up…</h2>

<p>Thanks to everyone who has gotten involved already, and special thanks to the RFC authors for your patience!</p>

<p>Sorry if you had an RFC that didn’t make the cut. 😕 We have a <a href="https://github.com/concourse/rfcs/pulls">backlog of 23 RFCs</a> at the moment, and I’ll be going through all of them through the next few posts.</p>

<p>Happy trails! 🐎</p>]]></content><author><name></name></author><category term="rfcs" /><summary type="html"><![CDATA[Howdy, and welcome to our first RFC round-up! 🤠]]></summary></entry><entry><title type="html">Community update: enter Discussions! 🎉</title><link href="http://localhost:4000/2020/04/16/nobody-wants-a-stale-bot.html" rel="alternate" type="text/html" title="Community update: enter Discussions! 🎉" /><published>2020-04-16T19:27:07-04:00</published><updated>2020-04-16T19:27:07-04:00</updated><id>http://localhost:4000/2020/04/16/nobody-wants-a-stale-bot</id><content type="html" xml:base="http://localhost:4000/2020/04/16/nobody-wants-a-stale-bot.html"><![CDATA[<p>Hasta la vista, stale bot.</p>

<figure class="kg-card kg-embed-card"><iframe width="480" height="270" src="https://www.youtube.com/embed/0Kug8mJ8WiM?start=110&amp;feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></figure>
<h2 id="tldr">tl;dr:</h2>

<ul>
  <li>We’ve been granted access to GitHub’s beta Discussions feature! 🎉</li>
  <li><a href="https://github.com/concourse/concourse/discussions">Discussions on the <code class="language-plaintext highlighter-rouge">concourse</code> repo</a> will be used for <strong>questions and technical support</strong>.</li>
  <li><a href="https://github.com/concourse/rfcs/discussions">Discussions on the <code class="language-plaintext highlighter-rouge">rfcs</code> repo</a> will be for <strong>incubating ideas for new workflows</strong> , which eventually turn into Pull Requests (also on the <code class="language-plaintext highlighter-rouge">rfcs</code> repo).</li>
  <li>From here on, Issues on the <code class="language-plaintext highlighter-rouge">concourse</code> repo are exclusively for <strong>project backlog</strong> and <strong>bug reports</strong> - i.e. planned or emergent work.</li>
  <li><a href="https://github.com/concourse/concourse/issues/new/choose">Creating an Issue</a> directs you to these options, so there’s no need to change your muscle memory.</li>
  <li><a href="https://github.com/concourse/concourse/blob/fab3de1722a2ce998d3710bd066453594f24ec57/CONTRIBUTING.md#from-ideas-to-implementation"><code class="language-plaintext highlighter-rouge">CONTRIBUTING.md</code> now covers this workflow</a> in addition to the more technical content.</li>
  <li>With these changes in place, the stale bot we all know and hate has been terminated.</li>
  <li>All Pull Requests will be assigned to someone as part of our daily process, and we will begin dedicating half of each day to PR review.</li>
  <li>I am going to shift my focus from planning/prioritizing to shepherding RFCs and writing code. Expect more blog posts in the future!</li>
</ul>

<h2 id="an-update-on-triage">An update on triage</h2>

<p>With Concourse, there is <em>always</em> a lot of work to do. I personally would love to see some of the <a href="https://github.com/concourse/concourse/issues/324">larger issues</a> worked on today, but we (the Concourse team) have to choose our battles. A good chunk of our time is spent on upkeep, architectural improvements, and trying to identify the underlying needs across many feature requests so that we can make a lower volume of high-impact changes.</p>

<p>The long and short of it is that the amount of work to do – both in code and in the community – greatly exceeds the number of people available to do it. Concourse is a product that has the <em>entire software industry</em> as its customer – including video game devs, mobile app devs, DevOps, and people who just want CI for personal side-projects. It’s a lot to stay on top of, but it’s something to embrace: it forces us to think in the abstract. It just takes time.</p>

<p>The main goal of these changes is to promote healthier discourse by setting expectations about the status of an engagement more clearly. Issues are concrete; they will be prioritized and finished at some point, by the core team or – in a perfect world – by a volunteer from the community. Discussions on the other hand are at an earlier stage in the process.</p>

<p>Discussions on the <code class="language-plaintext highlighter-rouge">concourse</code> repo will be used for for questions and support. These can be more open-ended than bug reports – there may indeed be a bug, but there might also just be an answer or a better approach. The outcome of these discussions may be a bug report, an improvement to the docs, an answer to the question, or perhaps a new Discussion on the <code class="language-plaintext highlighter-rouge">rfcs</code> repo.</p>

<p>Discussions on the <code class="language-plaintext highlighter-rouge">rfcs</code> repo will be used for incubating new ideas. By eliminating the “solution-first” framing of feature request issues, we can begin to focus on the <em>problems</em> instead. The hope is that we can all more easily identify underlying patterns and try to form broader solutions – whether they’re ones we need to plan, whether they’re already on the roadmap, or whether there’s simply an existing solution that needs to be easier to discover.</p>

<p>With these changes, we no longer have any need for the ‘stale bot’ as Discussions can just keep trucking along at their own pace. The bot has been terminated. Unfortunately, I removed its configuration before uninstalling it, causing it to assume the default settings and unleash its annoying comments across a slew of issues and pull requests, going out in one last blaze of glory. Sorry about that.</p>

<h2 id="improving-rfc-engagement">Improving RFC engagement</h2>

<p>Some of you have submitted RFCs and haven’t received much feedback yet. I’m really sorry about that.</p>

<p>With v6.0 out and with the dust settling on the <a href="__GHOST_URL__ /core-roadmap-towards-v10/">“v10” roadmap</a>, I am going to shift my role towards shepherding RFCs and getting back to writing code rather than endlessly planning and prioritizing. It’s been a long time! This will also eliminate the conflict-of-interest where I author RFCs and then prioritize them while neglecting others. Definitely not a trend that I want to continue.</p>

<p>Expect more RFC update blog posts soon!</p>

<h2 id="improving-pull-request-engagement">Improving Pull Request engagement</h2>

<p>Another area we’re always trying to improve on is Pull Request engagement. We’ve been tried a lot of things, but in the end it’s been hard to integrate into our day-to-day pairing process and escape the single-point-of-failure (<em>cough</em> me).</p>

<p>We’re going to start assigning each and every PR to someone on the team and dedicate half of each day to PR review. Our goal is to dramatically shorten the feedback cycle time and not leave anyone hanging.</p>

<h2 id="what-about-discussconcourse-ciorg">What about discuss.concourse-ci.org?</h2>

<p>These changes make <a href="https://discuss.concourse-ci.org">our forums</a> a little (ok a lot) redundant. Once the Discussions feature feels solid I plan to shut the forums down down and centralize our community in GitHub (in addition to Discord for real-time chat).</p>

<h2 id="whats-happening-with-vmware">What’s happening with VMware?</h2>

<p>Some of you may be wondering what the future holds for Concourse through VMware’s acquisition of Pivotal, the company that has supported Concourse’s development since 2015.</p>

<p>VMware is heavily invested in Concourse – in fact some of our recent significant contributions originated from VMware pre-acquisition. Concourse is already being used internally, and there is work underway planning Concourse’s integration into VMware’s product ecosystem. We ain’t going anywhere!</p>

<p>Thanks and stay safe everyone!</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Hasta la vista, stale bot.]]></summary></entry></feed>